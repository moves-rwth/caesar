"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[3668],{2526:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"heyvl/domains","title":"Domains, Uninterpreted Functions, and Axioms","description":"Domain blocks are used to create user-defined types and uninterpreted functions.","source":"@site/docs/heyvl/domains.md","sourceDirName":"heyvl","slug":"/heyvl/domains","permalink":"/docs/heyvl/domains","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/domains.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"description":"Domain blocks are used to create user-defined types and uninterpreted functions.","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Expressions","permalink":"/docs/heyvl/expressions"},"next":{"title":"Standard Library","permalink":"/docs/stdlib/"}}');var i=s(4848),t=s(8453);const a={description:"Domain blocks are used to create user-defined types and uninterpreted functions.",sidebar_position:4},r="Domains, Uninterpreted Functions, and Axioms",d={},c=[{value:"Example: Exponentials of \xbd",id:"example-exponentials-of-",level:2},{value:"Pure Functions",id:"pure-functions",level:2},{value:"Unsoundness From Axioms",id:"unsoundness-from-axioms",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"domains-uninterpreted-functions-and-axioms",children:"Domains, Uninterpreted Functions, and Axioms"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"domain"})," blocks are used to create user-defined types and uninterpreted functions.\nA domain has a name which can be used as a type in HeyVL code.\nThe domain block contains a list of ",(0,i.jsx)(n.code,{children:"func"}),"s and ",(0,i.jsx)(n.code,{children:"axiom"}),"s defined on this domain."]}),"\n",(0,i.jsxs)(n.p,{children:["Every domain type supports the binary operators ",(0,i.jsx)(n.code,{children:"=="})," and ",(0,i.jsx)(n.code,{children:"!="}),".\nAll other operations must be encoded using functions and axioms."]}),"\n",(0,i.jsx)(n.admonition,{title:"Unsoundness from Axioms",type:"warning",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"axiom"})," declarations behave like ",(0,i.jsxs)(n.a,{href:"/docs/heyvl/statements",children:[(0,i.jsx)(n.code,{children:"assume"})," statements"]})," and can quickly make verification unsound.\nE.g. ",(0,i.jsx)(n.code,{children:"axiom unsound ?(false)"})," behaves like ",(0,i.jsx)(n.code,{children:"assume ?(false)"}),", making everything verify.\n",(0,i.jsx)(n.a,{href:"#unsoundness-from-axioms",children:"See below for a longer example"}),"."]})}),"\n",(0,i.jsx)(n.admonition,{title:"Incompleteness from Quantifiers",type:"tip",children:(0,i.jsxs)(n.p,{children:["Note that axioms with quantifiers quickly introduce ",(0,i.jsx)(n.em,{children:"incompleteness"})," of Caesar, making it unable to prove or disprove verification.\nRead the documentation section on ",(0,i.jsx)(n.a,{href:"/docs/caesar/debugging#incompleteness",children:"SMT Theories and Incompleteness"})," for more information."]})}),"\n",(0,i.jsx)(n.h2,{id:"example-exponentials-of-",children:"Example: Exponentials of \xbd"}),"\n",(0,i.jsxs)(n.p,{children:["HeyVL does not support exponentiation expressions natively.\nBut we can define an uninterpreted function ",(0,i.jsx)(n.code,{children:"ohfive_exp"})," and add axioms that specify its result.\n",(0,i.jsx)(n.code,{children:"ohfive_exp(n)"})," should evaluate to ",(0,i.jsx)(n.code,{children:"(\xbd)\u207f"}),", so we add two axioms that define this exponential recursively."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ohfive_exp_base"})," states that ",(0,i.jsx)(n.code,{children:"ohfive_exp(0) == 1"})," and ",(0,i.jsx)(n.code,{children:"ohfive_exp_step"})," ensures that ",(0,i.jsx)(n.code,{children:"ohfive_exp(exponent + 1) == 0.5 * ohfive_exp(exponent)"})," holds.\nThis is sufficient to axiomatize our exponential function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-heyvl",children:"domain Exponentials {\n    func ohfive_exp(exponent: UInt): EUReal\n\n    axiom ohfive_exp_base ohfive_exp(0) == 1\n    axiom ohfive_exp_step forall exponent: UInt. ohfive_exp(exponent + 1) == 0.5 * ohfive_exp(exponent)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that this domain declaration creates a new type ",(0,i.jsx)(n.code,{children:"Exponentials"}),", but we do not use it."]}),"\n",(0,i.jsxs)(n.p,{children:["We can check that ",(0,i.jsx)(n.code,{children:"ohfive_exp(3)"})," evaluates to ",(0,i.jsx)(n.code,{children:"0.125"})," by declaring a ",(0,i.jsx)(n.a,{href:"/docs/heyvl/procs",children:"procedure"})," with pre-condition ",(0,i.jsx)(n.code,{children:"true"})," and post-condition ",(0,i.jsx)(n.code,{children:"ohfive_exp(3) == 0.125"}),".\nThis procedure verifies:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-heyvl",children:"proc ohfive_3() -> ()\n    pre ?(true)\n    post ?(ohfive_exp(3) == 0.125)\n{}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Do not forget the ",(0,i.jsx)(n.em,{children:"empty"})," block of statements ",(0,i.jsx)(n.code,{children:"{}"})," at the end.\nIf you omit it, ",(0,i.jsx)(n.a,{href:"/docs/heyvl/procs#procs-without-body",children:"Caesar will not attempt to verify the procedure"})," and thus will not check the specification."]}),"\n",(0,i.jsx)(n.h2,{id:"pure-functions",children:"Pure Functions"}),"\n",(0,i.jsxs)(n.p,{children:["You can also declare ",(0,i.jsx)(n.em,{children:"pure"})," or ",(0,i.jsx)(n.em,{children:"interpreted"})," functions.\nThese are defined by a single expression that computes the result of the function."]}),"\n",(0,i.jsxs)(n.p,{children:["The following function declaration has a such a definition (",(0,i.jsx)(n.code,{children:"= x + 1"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-heyvl",children:"func plus_one(x: UInt): UInt = x + 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"One can intuitively understand the above syntax as syntactic sugar for a function declaration with an additional axiom, i.e."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-heyvl",children:"func plus_one(x: UInt): UInt\naxiom plus_one_def forall x: UInt. plus_one(x) == x + 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, the ",(0,i.jsx)(n.em,{children:"pure"})," function syntax allows Caesar to make certain optimizations, therefore it should always be preferred."]}),"\n",(0,i.jsx)(n.h2,{id:"unsoundness-from-axioms",children:"Unsoundness From Axioms"}),"\n",(0,i.jsx)(n.p,{children:"Axioms are a dangerous feature because they can make verification unsound."}),"\n",(0,i.jsx)(n.p,{children:"An easy example is this one:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-heyvl",children:"domain Unsound {\n    axiom unsound false\n}\n\nproc wrong() -> ()\n    pre ?(true)\n    post ?(true)\n{\n    assert ?(false)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The axiom ",(0,i.jsx)(n.code,{children:"unsound"})," always evaluates to ",(0,i.jsx)(n.code,{children:"false"}),".\nBut for verification, Caesar assumes the axioms hold for all program states.\nIn other words, Caesar only verifies the program states in which the axioms evaluate to ",(0,i.jsx)(n.code,{children:"true"}),".\nThus, Caesar does not verify any program state and the procedure ",(0,i.jsx)(n.code,{children:"wrong"})," incorrectly verifies!"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var o=s(6540);const i={},t=o.createContext(i);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);