"use strict";(globalThis.webpackChunkcaesar_website=globalThis.webpackChunkcaesar_website||[]).push([[7220],{15569(e){e.exports=JSON.parse('{"permalink":"/blog/2026/01/15/popl26-ast-distributed","editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/blog/2026-01-15-popl26-ast-distributed.md","source":"@site/blog/2026-01-15-popl26-ast-distributed.md","title":"Verification of Almost-Sure Termination with Distributed Algorithms at POPL 2026","description":"The paper \\"Verifying Almost-Sure Termination for Randomized Distributed Algorithms\\" was presented at the ACM SIGPLAN Symposium on Principles of Programming Languages (POPL) 2026 held in Rennes, France.","date":"2026-01-15T00:00:00.000Z","tags":[{"inline":true,"label":"publications","permalink":"/blog/tags/publications"}],"readingTime":1.66,"hasTruncateMarker":true,"authors":[{"name":"Philipp Schroer","title":"Caesar Developer","url":"https://moves.rwth-aachen.de/people/philipp-schroer/","imageURL":"https://github.com/Philipp15b.png","key":"phisch","page":null}],"frontMatter":{"title":"Verification of Almost-Sure Termination with Distributed Algorithms at POPL 2026","authors":"phisch","tags":["publications"]},"unlisted":false,"nextItem":{"title":"Talk on Slicing at Dafny 2026","permalink":"/blog/2026/01/11/dafny26-slicing"}}')},28453(e,t,o){o.d(t,{R:()=>s,x:()=>a});var r=o(96540);const i={},n=r.createContext(i);function s(e){const t=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(n.Provider,{value:t},e.children)}},89060(e,t,o){o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>u});var r=o(15569),i=o(74848),n=o(28453);const s={title:"Verification of Almost-Sure Termination with Distributed Algorithms at POPL 2026",authors:"phisch",tags:["publications"]},a=void 0,l={authorsImageUrls:[void 0]},u=[];function p(e){const t={a:"a",em:"em",p:"p",...(0,n.R)(),...e.components},{Details:o}=t;return o||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The paper ",(0,i.jsx)(t.a,{href:"https://doi.org/10.1145/3776691",children:(0,i.jsx)(t.em,{children:'"Verifying Almost-Sure Termination for Randomized Distributed Algorithms"'})})," was presented at the ",(0,i.jsx)(t.a,{href:"https://popl26.sigplan.org/",children:"ACM SIGPLAN Symposium on Principles of Programming Languages (POPL) 2026"})," held in Rennes, France.\nThe authors are Constantin Enea (LIX, CNRS, Ecole Polytechnique), Rupak Majumdar (MPI-SWS), Harshit Jitendra Motwani (MPI-SWS), V.R. Sathiyanarayana (MPI-SWS)."]}),"\n",(0,i.jsx)(t.p,{children:"The paper presents a verification technique for liveness properties of randomized distributed algorithms.\nIt introduces a proof rule for fair almost-sure termination of distributed systems, combining martingale-based arguments for probabilistic termination with reasoning about weak fairness.\nThe proof rules are implemented in Caesar and were used to verify termination of randomized asynchronous consensus protocols, including Ben-Or\u2019s protocol and graded binary consensus, under both crash and Byzantine faults."}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsx)("summary",{children:"Full abstract (as provided by the authors)"}),(0,i.jsx)(t.p,{children:"We present a technique for the verification of liveness properties of randomized distributed algorithms. Our technique gives SMT-based proofs for many common consensus algorithms, both for crash faults and for Byzantine faults. It is based on a sound proof rule for fair almost-sure termination of distributed systems that combines martingale-based techniques for almost-sure termination with reasoning about weak fairness."}),(0,i.jsx)(t.p,{children:"Our proof rule is able to handle parametrized protocols where the state grows unboundedly and every variant function is unbounded. These protocols were out of scope for previous approaches, which either relied on bounded variant functions or on reductions to (non-probabilistic) fairness."}),(0,i.jsx)(t.p,{children:"We have implemented our proof rules on top of Caesar, a program verifier for probabilistic programs. We use our proof rule to give SMT-based proofs for termination properties of randomized asynchronous consensus protocols, including Ben-Or's protocol and graded binary consensus, for both crash and Byzantine faults. These protocols have notoriously difficult proofs of termination but fall within the scope of our proof rule."})]}),"\n",(0,i.jsx)(t.p,{children:"We will make more detailed information available on how to use these techniques with Caesar on this website in the future."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);