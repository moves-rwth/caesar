"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[311],{3088:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"model-checking","title":"Model Checking","description":"Caesar can export models to the JANI format.","source":"@site/docs/model-checking.md","sourceDirName":".","slug":"/model-checking","permalink":"/docs/model-checking","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/model-checking.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"description":"Caesar can export models to the JANI format."},"sidebar":"docsSidebar","previous":{"title":"Benchmarks","permalink":"/docs/caesar/benchmarks"},"next":{"title":"Development Guide","permalink":"/docs/devguide"}}');var r=s(4848),a=s(8453),i=s(8774);const o={sidebar_position:7,description:"Caesar can export models to the JANI format."},c="Model Checking",l={},d=[{value:"Usage",id:"usage",level:2},{value:"Option A: Caesar&#39;s <em>Storm</em> Backend",id:"caesars-storm-backend",level:3},{value:"Option B: Generating JANI Manually",id:"generating-jani-manually",level:3},{value:"Running Storm Manually",id:"running-storm-manually",level:4},{value:"Parametric and Infinite-State Models",id:"parametric-and-infinite-state-models",level:2},{value:"Relation to Caesar&#39;s Unrolling Proof Rule",id:"relation-to-caesars-unrolling-proof-rule",level:2},{value:"Supported Programs",id:"supported-programs",level:2},{value:"Supported Declarations",id:"supported-declarations",level:3},{value:"Supported Statements",id:"supported-statements",level:3},{value:"Initial Values of Output Parameters",id:"initial-values-of-output-parameters",level:4},{value:"Loop Semantics",id:"loop-semantics",level:4},{value:"Supported Types",id:"supported-types",level:3},{value:"Not Supported",id:"not-supported",level:3}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",math:"math",mi:"mi",mrow:"mrow",ol:"ol",p:"p",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",ul:"ul",...(0,a.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"model-checking",children:"Model Checking"})}),"\n","\n",(0,r.jsxs)(n.p,{children:["Caesar can export HeyVL programs to the ",(0,r.jsxs)(n.a,{href:"https://jani-spec.org/",children:[(0,r.jsx)(n.em,{children:"jani-model"})," format"]})," so they can be analyzed using probabilistic model checkers.\nThe JANI project defines exchange formats for quantitative model checking problems (and more).\nCaesar outputs ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Markov_chain",children:"Markov chains"})," (MCs) or ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Markov_decision_process",children:"Markov decision processes"})," (MDPs), depending on which HeyVL language features are used."]}),"\n",(0,r.jsxs)(n.p,{children:["The translation supports ",(0,r.jsx)(n.a,{href:"#supported-programs",children:"executable HeyVL programs"}),".\nThese are written in a subset of HeyVL, for which we have well-defined forwards-stepping MC/MDP semantics.\n",(0,r.jsx)(n.a,{href:"#not-supported",children:"Not supported right now"})," is local unbounded nondeterminism (",(0,r.jsx)(n.code,{children:"havoc"})," or uninitialized local variables), procedure calls or quantitative ",(0,r.jsx)(n.code,{children:"assume"})," statements."]}),"\n",(0,r.jsxs)(n.p,{children:["After exporting HeyVL programs to JANI, we can use probabilistic model checkers to calculate and/or verify expected rewards.\nIn contrast to Caesar, these do not need user annotations like ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"invariants"}),", but are fully automatic.\nOn the other hand, probabilistic model checkers often struggle with large or infinite state spaces.\nThus, the two approaches complement each other."]}),"\n",(0,r.jsxs)(n.p,{children:["We like the ",(0,r.jsxs)(n.a,{href:"https://www.stormchecker.org/",children:["probabilistic model checker ",(0,r.jsx)(n.em,{children:"Storm"})]}),".\nCaesar has a dedicated ",(0,r.jsx)(n.a,{href:"#caesars-storm-backend",children:"backend for Storm"})," to automatically run Storm and extract the results."]}),"\n",(0,r.jsx)("small",{children:(0,r.jsxs)(n.p,{children:["Note: Caesar should not be confused with the set of tools in the ",(0,r.jsx)(i.A,{to:"https://cadp.inria.fr/",children:"CADP toolbox"})," by INRIA, which includes tools like CAESAR, CAESAR.ADT, or OPEN/CAESAR.\nThese also enable model checking of software, but are unrelated to this project."]})}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.p,{children:"For a simple example, consider the HeyVL program below."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-heyvl",children:"@wp\nproc geo_mc() -> (c: UInt, cont: Bool)\n    post [!cont]\n{\n    c = 0\n    cont = true\n    while cont && c <= 20 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can either use Caesar's ",(0,r.jsxs)(n.a,{href:"#caesars-storm-backend",children:["automatic ",(0,r.jsx)(n.em,{children:"Storm"})," backend"]})," or ",(0,r.jsx)(n.a,{href:"#generating-jani-manually",children:"generate JANI manually"})," to use them however you wish."]}),"\n",(0,r.jsxs)(n.p,{children:["Caesar will assign arbitrary initial values to ",(0,r.jsx)(n.em,{children:"output parameters"})," and assumes that they are never read before they are written to.\nTo disable this or learn more, read the section on ",(0,r.jsx)(n.a,{href:"#initial-values-of-output-parameters",children:"initial values of output parameters"}),".\nIn addition, note that we always ",(0,r.jsx)(n.a,{href:"#loop-semantics",children:"use least-fixed point semantics for loops in the JANI translation"}),", therefore ",(0,r.jsxs)(n.a,{href:"/docs/proof-rules/calculi",children:[(0,r.jsx)(n.code,{children:"wlp"})," semantics"]})," is not supported."]}),"\n",(0,r.jsxs)(n.p,{children:["The generated Markov chain model is ",(0,r.jsx)(n.em,{children:"finite-state"})," and has a single initial state (no input parameters).\nYou'll usually want to maintain these restrictions when using a model checker.\nRead more about ",(0,r.jsx)(n.a,{href:"#parametric-and-infinite-state-models",children:"infinite-state and parametric models"})," below."]}),"\n",(0,r.jsxs)(n.h3,{id:"caesars-storm-backend",children:["Option A: Caesar's ",(0,r.jsx)(n.em,{children:"Storm"})," Backend"]}),"\n",(0,r.jsxs)(n.p,{children:["Caesar can automatically generate JANI files and run the ",(0,r.jsxs)(n.a,{href:"https://stormchecker.org",children:["probabilistic model checker ",(0,r.jsx)(n.em,{children:"Storm"})]}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["To enable it, pass the ",(0,r.jsx)(n.code,{children:"--run-storm OPTION"})," parameter to the command-line with one of the following values for ",(0,r.jsx)(n.code,{children:"OPTION"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"path"}),": Search for the Storm binary on the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/PATH_(variable)",children:(0,r.jsx)(n.code,{children:"PATH"})}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"docker-stable"}),": Run Storm via the ",(0,r.jsxs)(n.a,{href:"https://www.stormchecker.org/documentation/obtain-storm/docker.html",children:[(0,r.jsx)(n.code,{children:"movesrwth/storm:stable"})," Docker image"]}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"docker-ci"}),": Run Storm via the ",(0,r.jsxs)(n.a,{href:"https://www.stormchecker.org/documentation/obtain-storm/docker.html",children:[(0,r.jsx)(n.code,{children:"movesrwth/storm:ci"})," Docker image"]}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The latter two options need to have ",(0,r.jsx)(n.a,{href:"https://www.docker.com/",children:"Docker"})," installed and running.\nIf the images are not installed, Docker will download them automatically.\nThis might take a while."]}),"\n",(0,r.jsx)("small",{children:(0,r.jsxs)(n.p,{children:["Caesar does not automatically update these images.\nTo update the ",(0,r.jsx)(n.code,{children:":ci"})," image for example, run ",(0,r.jsx)(n.code,{children:"docker pull movesrwth/storm:ci"}),"."]})}),"\n",(0,r.jsxs)(n.p,{children:["The above flag can be used with Caesar's ",(0,r.jsx)(n.code,{children:"mc"})," command:\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"caesar mc --run-storm path example.heyvl\n"})}),"\n",(0,r.jsx)(n.p,{children:"The result will look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Expected reward from Storm: \u2248 0.9999995232\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The result is approximate because it was computed via floating-point arithmetic.\nTo get exact results at the expense of slower computation, you can add the ",(0,r.jsx)(n.code,{children:"--storm-exact"})," flag."]}),"\n",(0,r.jsxs)(n.p,{children:["You can also use the ",(0,r.jsx)(n.code,{children:"--run-storm"})," flag with the ",(0,r.jsxs)(n.a,{href:"/docs/caesar/#subcommand-caesar-verify",children:[(0,r.jsx)(n.code,{children:"verify"})," command"]})," or with ",(0,r.jsx)(n.a,{href:"/docs/caesar/vscode-and-lsp",children:"our LSP server"}),".\nFurthermore, you can set the ",(0,r.jsx)(n.code,{children:"--no-verify"})," flag to only run model checking and not run Caesar's deductive verification."]}),"\n",(0,r.jsx)(n.h3,{id:"generating-jani-manually",children:"Option B: Generating JANI Manually"}),"\n",(0,r.jsxs)(n.p,{children:["To export JANI files for the model checker, run Caesar with the ",(0,r.jsx)(n.code,{children:"mc"})," subcommand and the ",(0,r.jsx)(n.code,{children:"--jani-dir DIR"})," option to instruct it to save all translateable (co)procs to ",(0,r.jsx)(n.code,{children:".jani"})," files in the directory ",(0,r.jsx)(n.code,{children:"DIR"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"caesar mc example.heyvl --jani-dir DIR\n"})}),"\n",(0,r.jsx)(n.p,{children:"The output JANI files will have the following structure that you can use:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Properties:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"reward"}),": This is the expected value of the verification conditions (cf. ",(0,r.jsx)(n.a,{href:"/docs/heyvl/statements",children:"Statements"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"diverge_prob"}),": The probability of not reaching the end of the (co)proc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"can_diverge"}),": Boolean property whether the program has a path that does not reach the end of the (co)proc.",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Constants:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One constant for each input variable of the (co)proc (constant has same name as variable)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now you can use your favorite model checker with the resulting JANI files."}),"\n",(0,r.jsx)(n.h4,{id:"running-storm-manually",children:"Running Storm Manually"}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Quick Start: Using Storm via Docker."}),(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.a,{href:"https://www.docker.com/",children:"Docker"}),", you can download and run the latest version of Storm with just one command."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'docker run --mount type=bind,source="$(pwd)",target=/pwd -w /pwd --rm -it --name storm movesrwth/storm:stable storm [ARGS...]\n'})}),(0,r.jsxs)(n.p,{children:["This command will automatically download the latest stable build of Storm (c.f. ",(0,r.jsx)(n.a,{href:"https://hub.docker.com/r/movesrwth/storm/tags/",children:"list of Storm Docker image releases"}),").\nThe container will have the current directory mounted as ",(0,r.jsx)(n.code,{children:"/pwd"})," and the container will use that as the working directory.\nNote that this means you can only access files from your working directory inside the container.\nAfter running the command, the container will be deleted."]}),(0,r.jsxs)(n.p,{children:["Read more on ",(0,r.jsx)(n.a,{href:"https://www.stormchecker.org/documentation/obtain-storm/docker.html",children:"Storm's documentation page for its Docker containers"}),"."]})]}),"\n",(0,r.jsxs)(n.p,{children:["Running Storm on the produced file computes the expected reward.",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"storm --jani DIR/FILE.jani -jprop reward --exact --sound\n"})}),"\n",(0,r.jsx)(n.p,{children:"Part of the output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Model checking property "reward": R[exp]{"reward"}min=? [C] ...\nResult (for initial states): 2097151/2097152 (approx. 0.9999995232)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"parametric-and-infinite-state-models",children:"Parametric and Infinite-State Models"}),"\n",(0,r.jsxs)(n.p,{children:["Model checkers usually work with finite-state models with a single initial state, therefore programs that do not fit into this category are often not so simple to model check.\nWe modified our original example and added  an input parameter ",(0,r.jsx)(n.code,{children:"init_c"}),' (multiple initial states, therefore "parametric") and removed the bound on the loop (infinite number of states).']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-heyvl",children:"@wp\nproc geo_mc(init_c: UInt) -> (c: UInt, cont: Bool) // added input parameter init_c\n    post [!cont]\n{\n    c = init_c\n    cont = true\n    while cont { // removed condition && c <= 20\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With Caesar, we could run the following command to approximate the expected reward for the program with ",(0,r.jsx)(n.code,{children:"init_c = 5"})," with 10000 states:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"caesar mc --run-storm <VALUE> example.heyvl --storm-constants init_c=5 --storm-state-limit 10000\n"})}),"\n",(0,r.jsx)(n.p,{children:"And we get a result like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Expected reward from Storm: \u2a86 0.9999847412\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inputs Are Translated to Constants."}),"\nThe input parameters of the program are translated by Caesar to constants in the JANI model."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For the ",(0,r.jsx)(n.a,{href:"#caesars-storm-backend",children:"Caesar's Storm backend"})," can fix values with the ",(0,r.jsx)(n.code,{children:"--storm-constants <name>=<value>,...,<name>=<value>"})," command-line flag."]}),"\n",(0,r.jsxs)(n.li,{children:["Storm itself uses the ",(0,r.jsx)(n.code,{children:"--constants <name>=<value>,...,<name>=<value>"})," command-line flag."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Caesar can also be instructed to translate inputs to variables instead of constants with the ",(0,r.jsx)(n.code,{children:"--jani-no-constants"})," flag."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"State Limits to Approximate Infinite-State Models."}),"\nStorm can be used with a state limit so that the model generation will stop its exploration at some number of states.\nThis will yield a correct ",(0,r.jsx)(n.em,{children:"under"}),"-approximation of the expected reward."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.a,{href:"#caesars-storm-backend",children:"Caesar's Storm backend"}),", this as the ",(0,r.jsx)(n.code,{children:"--storm-state-limit <limit>"})," command-line flag."]}),"\n",(0,r.jsxs)(n.li,{children:["Storm itself uses the ",(0,r.jsx)(n.code,{children:"--state-limit <limit>"})," command-line flag."]}),"\n"]}),"\n",(0,r.jsx)("small",{children:(0,r.jsxs)(n.p,{children:["This feature is available since Storm 1.9.0 (",(0,r.jsx)(n.a,{href:"https://github.com/moves-rwth/storm/pull/521",children:"PR #521"}),")."]})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parametric Model Checking."}),"\nIf the program has input variables, ",(0,r.jsx)(n.a,{href:"https://www.stormchecker.org/documentation/usage/running-storm-on-parametric-models.html",children:"Storm's parametric model checking"})," may be of interest."]}),"\n",(0,r.jsx)(n.h2,{id:"relation-to-caesars-unrolling-proof-rule",children:"Relation to Caesar's Unrolling Proof Rule"}),"\n",(0,r.jsxs)(n.p,{children:["Caesar's ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/unrolling",children:"unrolling proof rule"})," can also be used to obtain sound bounds on expected rewards.\nThe unrolling proof rule is also sometimes called ",(0,r.jsx)(n.em,{children:"bounded model checking"}),".\nHowever, that proof rule is a bounded unrolling of the weakest pre-expectation semantics and therefore essentially an unrolling of all possible ",(0,r.jsx)(n.em,{children:"paths"})," in the Markov chain.\nIn contrast, the complexity of probabilistic model checking scales only in the number of ",(0,r.jsx)(n.em,{children:"states"})," and not in the number of paths.\nTherefore, these techniques are somewhat related, but distinct."]}),"\n",(0,r.jsxs)(n.p,{children:["For the original non-parametric example from the ",(0,r.jsx)(n.a,{href:"#usage",children:"Usage section"}),", we obtain the optimal lower bound in Caesar without using a model checker.\nThe annotation ",(0,r.jsx)(n.code,{children:"@unroll(22, 0)"})," for unrolling depth 22 finds the optimal value in this case."]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Unrolling Proof Rule Example"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-heyvl",children:"@wp\nproc geo_mc() -> (c: UInt, cont: Bool)\n    post [!cont]\n{\n    c = 0\n    cont = true\n    @unroll(22, 0)\n    while cont && c <= 20 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),(0,r.jsxs)(n.p,{children:["Because we gave no ",(0,r.jsx)(n.code,{children:"pre"}),", Caesar will try to verify whether ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\infty"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"})]})})]})," is a lower bound to the expected value.\nWe get a counter-example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Counter-example to verification found!\n\nthe pre-quantity evaluated to:\n    0.99999... (2097151/2097152)\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"supported-programs",children:"Supported Programs"}),"\n",(0,r.jsxs)(n.p,{children:["The translation to JANI supports a large subset of the HeyVL language.\nYou can use for example assignments, loops, conditionals, and probabilistic choices.\nNondeterministic choices and assertions are also supported, as well as Boolean ",(0,r.jsx)(n.code,{children:"assume"})," statements.\n",(0,r.jsx)(n.a,{href:"#not-supported",children:"Not supported right now"})," is local unbounded nondeterminism (",(0,r.jsx)(n.code,{children:"havoc"})," or uninitialized local variables), procedure calls or quantitative ",(0,r.jsx)(n.code,{children:"assume"})," statements."]}),"\n",(0,r.jsx)(n.h3,{id:"supported-declarations",children:"Supported Declarations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"proc"})," and ",(0,r.jsx)(n.code,{children:"coproc"})," specifications with:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Inputs and output declarations,"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pre"})," declarations that are only Boolean conditions of the form ",(0,r.jsx)(n.code,{children:"?(b)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"post"})," declarations (arbitrary operands)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.a,{href:"/docs/heyvl/domains#definitional-functions",children:["definitional ",(0,r.jsx)(n.code,{children:"func"}),"s"]})," (",(0,r.jsx)(n.em,{children:"not"})," uninterpreted functions)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"supported-statements",children:"Supported Statements"}),"\n",(0,r.jsx)(n.p,{children:"In the body, statements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#blocks",children:"Blocks"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#variable-declarations",children:"Variable declarations"})," with initializers,"]}),"\n",(0,r.jsx)(n.li,{children:"Assignments with pure expressions,"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/distributions",children:"Sampling from distributions"}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#boolean-choices",children:"If-then-else statements"}),","]}),"\n",(0,r.jsxs)(n.li,{children:["While loops (with least-fixed point semantics \u2014 ",(0,r.jsx)(n.a,{href:"#loop-semantics",children:"see below for semantics details"}),"),"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.a,{href:"/docs/heyvl/statements#reward",children:[(0,r.jsx)(n.code,{children:"reward"})," statements"]}),","]}),"\n",(0,r.jsxs)(n.li,{children:["In ",(0,r.jsx)(n.code,{children:"proc"}),"s:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.a,{href:"/docs/heyvl/statements#assert-and-assume",children:[(0,r.jsx)(n.code,{children:"assert"})," statements"]}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#nondeterministic-choices",children:"Binary demonic choices"}),","]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["In ",(0,r.jsx)(n.code,{children:"coproc"}),"s:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.a,{href:"/docs/heyvl/statements#assert-and-assume",children:[(0,r.jsx)(n.code,{children:"coassert"})," statements"]}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#nondeterministic-choices",children:"Binary angelic choices"}),","]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/statements#assert-and-assume",children:"Assumptions"})," of the form ",(0,r.jsx)(n.code,{children:"assume ?(b)"})," and ",(0,r.jsx)(n.code,{children:"coassume !?(b)"}),","]}),"\n",(0,r.jsxs)(n.li,{children:["Annotations, in particular ",(0,r.jsx)(n.a,{href:"./proof-rules/",children:"proof rule annotations"}),", will be ignored."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"initial-values-of-output-parameters",children:"Initial Values of Output Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["Caesar will try to choose valid initial values for variables of built-in types such as ",(0,r.jsx)(n.code,{children:"Bool"}),".\nThis reduces the number of initial states the model checker has to check.\nWe do this in a way that is not observable to the program, with one exception."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"By default, the JANI translation will assign arbitrary initial values to output variables.\nThis is correct when output variables are never read before they are written to.\nHowever, if uninitialized output variables are read, then the choice is observable."})}),"\n",(0,r.jsxs)(n.p,{children:["This behavior can be disabled with the ",(0,r.jsx)(n.code,{children:"--jani-uninit-outputs"})," option so that output variables are left uninitialized in the JANI model."]}),"\n",(0,r.jsx)(n.h4,{id:"loop-semantics",children:"Loop Semantics"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["In the JANI translation, while loops are always assumed to have ",(0,r.jsx)(n.strong,{children:"least fixed-point semantics"})," when model-checking.",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),"\nThat means we just accumulate total expected rewards over all terminating executions in the Markov chain.\nThis corresponds to ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"wp/ert"})," semantics."]})}),"\n",(0,r.jsxs)(n.p,{children:["Notice that in ",(0,r.jsx)(n.code,{children:"proc"}),"s, this is different from the default behavior of Caesar's ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"proof rules such as induction"}),".\nThey would assume greatest fixed-point (wlp) semantics in ",(0,r.jsx)(n.code,{children:"proc"}),"s.\nWe recommend always adding the ",(0,r.jsxs)(n.a,{href:"/docs/proof-rules/calculi",children:[(0,r.jsx)(n.code,{children:"@wp"})," or ",(0,r.jsx)(n.code,{children:"@ert"})," annotations"]})," to your ",(0,r.jsx)(n.code,{children:"proc"}),"/",(0,r.jsx)(n.code,{children:"coproc"}),".\nThey instruct Caesar to enforce that sound proof rules for least fixed-point semantics are being used."]}),"\n",(0,r.jsxs)(n.p,{children:["If you want ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"one-bounded wlp semantics"})," (greatest fixed-points), then you can use the generated property ",(0,r.jsx)(n.code,{children:"diverge_prob"})," to obtain the probability of divergence.\nThen the result should be the sum of the ",(0,r.jsx)(n.code,{children:"reward"})," and ",(0,r.jsx)(n.code,{children:"diverge_prob"})," properties (Storm: ",(0,r.jsx)(n.code,{children:"-jprop reward,diverge_prob"}),").",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})})]}),"\n",(0,r.jsxs)(n.p,{children:["If you want ",(0,r.jsx)(n.em,{children:"unbounded"})," greatest fixed-point semantics, then you can use the generated property ",(0,r.jsx)(n.code,{children:"can_diverge"})," to check whether there is a diverging path.\nThen the result is ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\infty"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"})]})})]})," if ",(0,r.jsx)(n.code,{children:"can_diverge"})," is ",(0,r.jsx)(n.code,{children:"true"}),", otherwise the result is ",(0,r.jsx)(n.code,{children:"reward"}),".",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),"\nThis property is currently not supported by Storm.",(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,r.jsxs)(n.p,{children:["We intentionally avoid using the ",(0,r.jsx)(n.em,{children:"reachability reward"})," properties (i.e. setting the ",(0,r.jsx)(n.code,{children:"reach"})," property of ",(0,r.jsx)(n.code,{children:"ExpectedValueExpression"})," in JANI) as it will assign the expected reward ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\infty"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"})]})})]})," to any state from which goal states are not reachable with probability 1.\nIf the program is not AST, then this does not correspond to either least or greatest fixpoint semantics weakest pre-expectation style semantics that we know of."]}),"\n",(0,r.jsx)(n.h3,{id:"supported-types",children:"Supported Types"}),"\n",(0,r.jsx)(n.p,{children:"The supported types of values are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/booleans",children:(0,r.jsx)(n.code,{children:"Bool"})}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#uint",children:(0,r.jsx)(n.code,{children:"UInt"})}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#int",children:(0,r.jsx)(n.code,{children:"Int"})}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#ureal",children:(0,r.jsx)(n.code,{children:"UReal"})}),","]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#real",children:(0,r.jsx)(n.code,{children:"Real"})}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Make sure to check in your model checker's documentation how these types are realized.\nFor example, ",(0,r.jsx)(n.a,{href:"https://www.stormchecker.org",children:"Storm"})," assumes 32-bit numbers by default for unbounded integer types."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#eureal",children:(0,r.jsx)(n.code,{children:"EUReal"})})," values are currently only supported as values in ",(0,r.jsx)(n.code,{children:"pre"}),"/",(0,r.jsx)(n.code,{children:"post"})," declarations and in ",(0,r.jsx)(n.code,{children:"assert"})," statements.\nThe value ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\infty"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"})]})})]})," cannot be explicitly represented in JANI, therefore ",(0,r.jsx)(n.code,{children:"EUReal"})," expressions that go beyond the specific supported verification constructs are not supported."]}),"\n",(0,r.jsx)(n.h3,{id:"not-supported",children:"Not Supported"}),"\n",(0,r.jsxs)(n.p,{children:["In particular, the following constructs are ",(0,r.jsx)(n.em,{children:"not"})," supported:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Calls to uninterpreted functions or to ",(0,r.jsx)(n.code,{children:"proc"}),"s/",(0,r.jsx)(n.code,{children:"coproc"}),"s,"]}),"\n",(0,r.jsxs)(n.li,{children:["Uninitialized variable declarations or ",(0,r.jsx)(n.code,{children:"havoc"}),"/",(0,r.jsx)(n.code,{children:"cohavoc"})," statements,"]}),"\n",(0,r.jsxs)(n.li,{children:["Quantitative ",(0,r.jsx)(n.code,{children:"assume"})," or ",(0,r.jsx)(n.code,{children:"coassume"})," statements."]}),"\n",(0,r.jsxs)(n.li,{children:["In ",(0,r.jsx)(n.a,{href:"/docs/heyvl/domains",children:"user-defined domains"}),", uninterpreted functions are not supported and axioms will be ignored."]}),"\n"]}),"\n","\n",(0,r.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{id:"user-content-fn-5",children:["\n",(0,r.jsxs)(n.p,{children:["Storm currently does not support the qualitative analysis required for the ",(0,r.jsx)(n.code,{children:"can_diverge"})," property and will throw an error. The feature is tracked in the issue ",(0,r.jsx)(n.a,{href:"https://github.com/moves-rwth/storm/issues/529",children:"moves-rwth/storm#529"}),". ",(0,r.jsx)(n.a,{href:"#user-content-fnref-5","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})," ",(0,r.jsxs)(n.a,{href:"#user-content-fnref-5-2","data-footnote-backref":"","aria-label":"Back to reference 1-2",className:"data-footnote-backref",children:["\u21a9",(0,r.jsx)(n.sup,{children:"2"})]})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,r.jsxs)(n.p,{children:["We use the ",(0,r.jsx)(n.code,{children:"--exact"})," and ",(0,r.jsx)(n.code,{children:"--sound"})," flags to ensure that Storm is forced to use exact arithmetic and only sound algorithms to produce the solution. Consult your chosen model checker's documentation to see which guarantees they give. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,r.jsxs)(n.p,{children:["We always use least-fixed point semantics because encoding greatest fixpoint/weakest ",(0,r.jsx)(n.em,{children:"liberal"})," pre-expectation semantics seems to be impossible with a single JANI property right now. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://publications.rwth-aachen.de/record/755408/files/755408.pdf#page=115",children:"Corollary 4.26 of Benjamin Kaminski's PhD thesis"})," states that (one-bounded) ",(0,r.jsx)(n.code,{children:"wlp"})," can be computed via ",(0,r.jsx)(n.code,{children:"wp"})," plus the probability of divergence. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-4",children:["\n",(0,r.jsxs)(n.p,{children:["This is similar to the qualitative wlp, which evaluates to the top element of the Boolean lattice (",(0,r.jsx)(n.code,{children:"true"}),") if the loop has a possibility of nontermination. In the quantitative setting, we have ",(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsx)(n.mrow,{children:(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"})}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\infty"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"})]})})]})," as our top element of the ",(0,r.jsx)(n.a,{href:"/docs/stdlib/numbers#eureal",children:(0,r.jsx)(n.code,{children:"EUReal"})})," lattice. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-4","data-footnote-backref":"","aria-label":"Back to reference 5",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);