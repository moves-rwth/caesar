"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[235],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(a),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8433:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:7,description:"Caesar can export models to the JANI format."},o="Model Checking",l={unversionedId:"model-checking",id:"model-checking",title:"Model Checking",description:"Caesar can export models to the JANI format.",source:"@site/docs/model-checking.md",sourceDirName:".",slug:"/model-checking",permalink:"/docs/model-checking",draft:!1,editUrl:"https://github.com/moves-rwth/caesar/tree/main/website/docs/model-checking.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,description:"Caesar can export models to the JANI format."},sidebar:"docsSidebar",previous:{title:"Benchmarks",permalink:"/docs/caesar/benchmarks"},next:{title:"Development Guide",permalink:"/docs/devguide"}},s={},p=[{value:"Usage",id:"usage",level:2},{value:"Supported Programs",id:"supported-programs",level:2},{value:"Supported Declarations",id:"supported-declarations",level:3},{value:"Supported Statements",id:"supported-statements",level:3},{value:"Loop Semantics",id:"loop-semantics",level:4},{value:"Supported Types",id:"supported-types",level:3},{value:"Not Supported",id:"not-supported",level:3}],c={toc:p},m="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"model-checking"},"Model Checking"),(0,r.kt)("p",null,"Caesar has some support to export probabilistic programs written in (an executable fragment of) HeyVL to ",(0,r.kt)("a",{parentName:"p",href:"https://jani-spec.org/"},"the ",(0,r.kt)("em",{parentName:"a"},"jani-model")," format"),".\nThe JANI project defines exchange formats for quantitative model checking problems (and more)."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#supported-programs"},"Executable HeyVL programs")," are essentially programs without verification statements, where therefore the Markov chain semantics is clearly defined and the program can be executed forwards in a step-by-step fashion."),(0,r.kt)("p",null,"After exporting HeyVL programs to JANI, we can use our favorite probabilistic model checkers to calculate and/or verify expected rewards.\nFor now, we have only tested with the ",(0,r.kt)("a",{parentName:"p",href:"https://www.stormchecker.org/"},"model checker ",(0,r.kt)("em",{parentName:"a"},"Storm")),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This feature is still under development.\nThere are sure to be bugs and missing functionality.\nThe encoding is sure to change in the near future.")),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,"For a simple example, consider the HeyVL program below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"@wp\nproc geo_mc(init_c: UInt) -> (c: UInt, cont: Bool)\n    post [!cont]\n{\n    c = init_c\n    cont = true\n    while cont && c <= 20 {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n")),(0,r.kt)("p",null,"To export JANI files for the model checker, simply run Caesar with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--jani-dir DIR")," option to instruct it to save all translateable (co)procs to ",(0,r.kt)("inlineCode",{parentName:"p"},".jani")," files in the directory ",(0,r.kt)("inlineCode",{parentName:"p"},"DIR"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"caesar example.heyvl --jani-dir DIR\n")),(0,r.kt)("p",null,"We use the probabilistic model checker ",(0,r.kt)("a",{parentName:"p",href:"https://www.stormchecker.org"},"Storm"),".\nRunning Storm on the produced file gives us the optimal value.",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"\nProcedure inputs to are translated to JANI's ",(0,r.kt)("em",{parentName:"p"},"constants"),", and must be given to Storm via the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"--constants init_c=0")," (any other initial value can be chosen)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ storm --jani DIR/FILE.jani -jprop reward --exact --sound --constants init_c=0\n")),(0,r.kt)("p",null,"Part of the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Model checking property "reward": R[exp]{"reward"}min=? [C] ...\nResult (for initial states): 2097151/2097152 (approx. 0.9999995232)\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In this particular case, we can obtain the optimal lower bound in Caesar by using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/unrolling"},"unrolling proof rule"),".\nThe annotation ",(0,r.kt)("inlineCode",{parentName:"p"},"@unroll(22, 0)")," for unrolling depth 22 finds the fixpoint in this case.\nBut this is only exact if we can bound the number of loop iterations statically.")),(0,r.kt)("h2",{id:"supported-programs"},"Supported Programs"),(0,r.kt)("p",null,"The currently implemented translation only supports a subset of the executable fragment of HeyVL."),(0,r.kt)("h3",{id:"supported-declarations"},"Supported Declarations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"proc")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"coproc")," specifications with:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Inputs and output declarations,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pre")," declarations that are only Boolean conditions of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"?(b)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"post")," declarations (arbitrary operands).")))),(0,r.kt)("h3",{id:"supported-statements"},"Supported Statements"),(0,r.kt)("p",null,"In the body, statements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#blocks"},"Blocks"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#variable-declarations"},"Variable declarations")," with initializers,"),(0,r.kt)("li",{parentName:"ul"},"Assignments with pure expressions,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/distributions"},"Sampling from distributions"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#reward-formerly-tick"},(0,r.kt)("inlineCode",{parentName:"a"},"reward")," statements"),","),(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"proc"),"s:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#assert-and-assume"},(0,r.kt)("inlineCode",{parentName:"a"},"assert")," statements")," with Boolean condition of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"assert ?(b)"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#nondeterministic-choices"},"Binary demonic choices"),","))),(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"coproc"),"s:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#nondeterministic-choices"},"Binary angelic choices"),","))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/statements#boolean-choices"},"If-then-else statements"),","),(0,r.kt)("li",{parentName:"ul"},"While loops (with least-fixed point semantics ","\u2014"," ",(0,r.kt)("a",{parentName:"li",href:"#loop-semantics"},"see below for semantics details"),"),"),(0,r.kt)("li",{parentName:"ul"},"Annotations, in particular ",(0,r.kt)("a",{parentName:"li",href:"./proof-rules/"},"proof rule annotations"),", will be ignored.")),(0,r.kt)("h4",{id:"loop-semantics"},"Loop Semantics"),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"In the JANI translation, while loops are always assumed to have ",(0,r.kt)("strong",{parentName:"p"},"least fixed-point semantics")," when model-checking.",(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"\nThat means we just accumulate total expected rewards over all terminating executions in the Markov chain.\nThis corresponds to ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/calculi"},"wp/ert")," semantics.")),(0,r.kt)("p",null,"Notice that in ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),"s, this is different from the default behavior of Caesar's ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},"proof rules such as induction"),".\nThey would assume greatest fixed-point (wlp) semantics in ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),"s.\nWe recommend always adding the ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/calculi"},(0,r.kt)("inlineCode",{parentName:"a"},"@wp")," or ",(0,r.kt)("inlineCode",{parentName:"a"},"@ert")," annotations")," to your ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"coproc"),".\nThey instruct Caesar to enforce that sound proof rules for least fixed-point semantics are being used."),(0,r.kt)("p",null,"If you want ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/calculi"},"one-bounded wlp semantics")," (greatest fixed-points), then you can use the generated property ",(0,r.kt)("inlineCode",{parentName:"p"},"diverge_prob")," to obtain the probability of divergence.\nThen the result should be the sum of the ",(0,r.kt)("inlineCode",{parentName:"p"},"reward")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"diverge_prob")," properties (Storm: ",(0,r.kt)("inlineCode",{parentName:"p"},"-jprop reward,diverge_prob"),").",(0,r.kt)("sup",{parentName:"p",id:"fnref-3"},(0,r.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,r.kt)("p",null,"If you want ",(0,r.kt)("em",{parentName:"p"},"unbounded")," greatest fixed-point semantics, then you can use the generated property ",(0,r.kt)("inlineCode",{parentName:"p"},"can_diverge")," to check whether there is a diverging path.\nThen the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"\\infty")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"can_diverge")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", otherwise the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"reward"),".",(0,r.kt)("sup",{parentName:"p",id:"fnref-4"},(0,r.kt)("a",{parentName:"sup",href:"#fn-4",className:"footnote-ref"},"4")),"\nThis property is currently not supported by Storm.",(0,r.kt)("sup",{parentName:"p",id:"fnref-5"},(0,r.kt)("a",{parentName:"sup",href:"#fn-5",className:"footnote-ref"},"5"))),(0,r.kt)("p",null,"We intentionally avoid using the ",(0,r.kt)("em",{parentName:"p"},"reachability reward")," properties (i.e. setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"reach")," property of ",(0,r.kt)("inlineCode",{parentName:"p"},"ExpectedValueExpression")," in JANI) as it will assign the expected reward ",(0,r.kt)("inlineCode",{parentName:"p"},"\\infty")," to any state from which goal states are not reachable with probability 1.\nIf the program is not AST, then this does not correspond to either least or greatest fixpoint semantics weakest pre-expectation style semantics that we know of."),(0,r.kt)("h3",{id:"supported-types"},"Supported Types"),(0,r.kt)("p",null,"The supported types of values are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/booleans"},(0,r.kt)("inlineCode",{parentName:"a"},"Bool")),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/numbers#uint"},(0,r.kt)("inlineCode",{parentName:"a"},"UInt")),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/numbers#int"},(0,r.kt)("inlineCode",{parentName:"a"},"Int")),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/numbers#ureal"},(0,r.kt)("inlineCode",{parentName:"a"},"UReal")),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/numbers#real"},(0,r.kt)("inlineCode",{parentName:"a"},"Real")),".")),(0,r.kt)("p",null,"Make sure to check in your model checker's documentation how these types are realized.\nFor example, ",(0,r.kt)("a",{parentName:"p",href:"https://www.stormchecker.org"},"Storm")," assumes 32-bit numbers by default for unbounded integer types."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/stdlib/numbers#eureal"},(0,r.kt)("inlineCode",{parentName:"a"},"EUReal"))," values are currently only supported as values in ",(0,r.kt)("inlineCode",{parentName:"p"},"pre"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"post")," declarations and in ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," statements.\nThe value ",(0,r.kt)("inlineCode",{parentName:"p"},"\\infty")," cannot be explicitly represented in JANI, therefore ",(0,r.kt)("inlineCode",{parentName:"p"},"EUReal")," expressions that go beyond the specific supported verification constructs are not supported."),(0,r.kt)("h3",{id:"not-supported"},"Not Supported"),(0,r.kt)("p",null,"In particular, the following constructs are ",(0,r.kt)("em",{parentName:"p"},"not")," supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Calls to uninterpreted functions or to ",(0,r.kt)("inlineCode",{parentName:"li"},"proc"),"s/",(0,r.kt)("inlineCode",{parentName:"li"},"coproc"),"s,"),(0,r.kt)("li",{parentName:"ul"},"Uninitialized variable declarations or ",(0,r.kt)("inlineCode",{parentName:"li"},"havoc"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"cohavoc")," statements,"),(0,r.kt)("li",{parentName:"ul"},"Quantitative verification statements such as ",(0,r.kt)("inlineCode",{parentName:"li"},"assume"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"assert")," in arbitrary locations."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/heyvl/domains"},"User-defined domains"),", axioms will be ignored.")),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"We use the ",(0,r.kt)("inlineCode",{parentName:"li"},"--exact")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"--sound")," flags to ensure that Storm is forced to use exact arithmetic and only sound algorithms to produce the solution. Consult your chosen model checker's documentation to see which guarantees they give.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"We always use least-fixed point semantics because encoding greatest fixpoint/weakest ",(0,r.kt)("em",{parentName:"li"},"liberal")," pre-expectation semantics seems to be impossible with a single JANI property right now.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-3"},(0,r.kt)("a",{parentName:"li",href:"https://publications.rwth-aachen.de/record/755408/files/755408.pdf#page=115"},"Corollary 4.26 of Benjamin Kaminski's PhD thesis")," states that (one-bounded) ",(0,r.kt)("inlineCode",{parentName:"li"},"wlp")," can be computed via ",(0,r.kt)("inlineCode",{parentName:"li"},"wp")," plus the probability of divergence.",(0,r.kt)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-4"},"This is similar to the qualitative wlp, which evaluates to the top element of the Boolean lattice (",(0,r.kt)("inlineCode",{parentName:"li"},"true"),") if the loop has a possibility of nontermination. In the quantitative setting, we have ",(0,r.kt)("inlineCode",{parentName:"li"},"\\infty")," as our top element of the ",(0,r.kt)("a",{parentName:"li",href:"/docs/stdlib/numbers#eureal"},(0,r.kt)("inlineCode",{parentName:"a"},"EUReal"))," lattice.",(0,r.kt)("a",{parentName:"li",href:"#fnref-4",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-5"},"Storm currently does not support the qualitative analysis required for the ",(0,r.kt)("inlineCode",{parentName:"li"},"can_diverge")," property and will throw an error. The feature is tracked in the issue ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/moves-rwth/storm/issues/529"},"moves-rwth/storm#529"),".",(0,r.kt)("a",{parentName:"li",href:"#fnref-5",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0}}]);