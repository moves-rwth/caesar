"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[2762],{941:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"caesar/debugging","title":"Debugging","description":"Follow this guide if you are debugging verification with Caesar.","source":"@site/docs/caesar/debugging.md","sourceDirName":"caesar","slug":"/caesar/debugging","permalink":"/docs/caesar/debugging","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/caesar/debugging.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"The Caesar Tool","permalink":"/docs/caesar/"},"next":{"title":"VSCode Extension & LSP Support","permalink":"/docs/caesar/vscode-and-lsp"}}');var t=i(4848),r=i(8453);const o={sidebar_position:1},a="Debugging",l={},c=[{value:"Disabling Slicing",id:"disabling-slicing",level:2},{value:"SMT Theories and Incompleteness",id:"incompleteness",level:2},{value:"Z3 Probes",id:"z3-probes",level:3},{value:"Z3 Statistics",id:"z3-statistics",level:3},{value:"Debugging Quantifier Instantiations",id:"debugging-quantifier-instantiations",level:2},{value:"Function Encodings and Limited Functions",id:"function-encodings-and-limited-functions",level:3},{value:"Literals",id:"literals",level:4},{value:"Termination",id:"termination",level:4},{value:"No Synonym Axiom Option",id:"no-synonym-axiom-option",level:4},{value:"Selecting Quantifier Instantiation Strategies",id:"selecting-quantifier-instantiation-strategies",level:3},{value:"Simple QI Profiling",id:"simple-qi-profiling",level:3},{value:"MBQI Tracing",id:"mbqi-tracing",level:3},{value:"Debugging with SMTscope",id:"debugging-with-smtscope",level:3},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"debugging",children:"Debugging"})}),"\n",(0,t.jsx)(n.p,{children:"Follow this guide if you are debugging verification with Caesar."}),"\n",(0,t.jsx)(n.h2,{id:"disabling-slicing",children:"Disabling Slicing"}),"\n",(0,t.jsxs)(n.p,{children:["By default, Caesar will use ",(0,t.jsx)(n.a,{href:"/docs/caesar/slicing",children:"slicing"})," for error localization.\nIf you're just interested in simple results (verified/not verified), it might be helpful to disable/limit slicing."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"--no-slice-error"})," to disable error localization completely.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This will disable any slicing-related encoding in the SMT formula."}),"\n",(0,t.jsxs)(n.li,{children:["For HeyVL programs with many assert-like statements, this can massively improve performance. This occurs when using e.g. ",(0,t.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"k-induction"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"--slice-error-first"})," to tell Caesar not to attempt to minimize the error slice, but use the first one it finds.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The generated SMT formula will still contain slicing-related logic."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"incompleteness",children:"SMT Theories and Incompleteness"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/heyvl/expressions",children:"Expressions"})," are the main reason for ",(0,t.jsx)(n.em,{children:"incompleteness"})," of Caesar, i.e. instances Caesar is unable to decide whether a given HeyVL program verifies or not.\nCaesar's incompleteness comes from incompleteness of the underlying SMT solver which is used to prove or disprove verification."]}),"\n",(0,t.jsxs)(n.p,{children:["At the moment, Caesar's translation of HeyVL verification problems is rather direct: most expressions are translated as one would intuitively expect.\nIf operators have a direct correspondence in ",(0,t.jsx)(n.a,{href:"https://smt-lib.org/",children:"SMT-LIB"}),", then we translate directly to those.\nOtherwise, usually only additional simple case distinctions are introduced.\nWe have some more explanations in ",(0,t.jsx)(n.a,{href:"https://arxiv.org/pdf/2309.07781#page=23",children:"Section 5 of our paper on HeyVL"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["As a consequence, it is usually pretty simple to predict which ",(0,t.jsx)(n.a,{href:"https://smt-lib.org/theories.shtml",children:"SMT-LIB theories"})," will be used for the SMT query done by Caesar.\n",(0,t.jsx)(n.a,{href:"#z3-probes",children:"Caesar supports Z3 probes"})," to help you check in which theory your problem falls.\nAlso refer to the ",(0,t.jsx)(n.a,{href:"https://microsoft.github.io/z3guide/docs/theories/Arithmetic/",children:"Z3 documentation on arithmetic theories"}),", since a lot of Caesar's reasoning will need arithmetic."]}),"\n",(0,t.jsx)(n.p,{children:"Here are some rules of thumb for (in-)completeness:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linear integer and real arithmetic (QF_LRA, QF_LIRA) is decidable."}),"\n",(0,t.jsx)(n.li,{children:"Nonlinear integer arithmetic (QF_NIA) is undecidable."}),"\n",(0,t.jsx)(n.li,{children:"Nonlinear real arithmetic (QF_NRA) is decidable for algebraic reals."}),"\n",(0,t.jsxs)(n.li,{children:["Quantifiers usually introduce undecidability, although there are ",(0,t.jsx)(n.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Quantifiers#model-based-quantifier-instantiation",children:"a bunch of strategies and fragments in Z3 that allow decidability"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In particular, restrictive ",(0,t.jsx)(n.a,{href:"/docs/heyvl/expressions#triggers",children:"quantifier triggers"})," can help e-matching prove many instances."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/heyvl/domains#definitional-functions",children:"Definitional functions"})," can introduce nontermination. See the section on ",(0,t.jsx)(n.a,{href:"#function-encodings-and-limited-functions",children:"function encodings and limited functions"})," for more information."]}),"\n",(0,t.jsxs)(n.li,{children:["HeyVL's ",(0,t.jsx)(n.a,{href:"/docs/heyvl/expressions#quantifiers",children:"quantitative quantifiers"})," (",(0,t.jsx)(n.code,{children:"inf"})," and ",(0,t.jsx)(n.code,{children:"sup"}),") currently have a very naive default encoding that is problematic for Z3.  If the quantitative quantifiers cannot be eliminated by Caesar's quantifier elimination (QE) procedure, then they are often a cause of nontermination of Caesar.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Quantitative quantifiers also come from the semantics of ",(0,t.jsxs)(n.a,{href:"/docs/heyvl/statements#havoc",children:[(0,t.jsx)(n.code,{children:"havoc"})," and ",(0,t.jsx)(n.code,{children:"cohavoc"})]}),". However, for e.g. the ",(0,t.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"induction-based proof rules"}),", the HeyVL encodings fall into a fragment where Caesar's QE applies and the generated quantifiers are eliminated."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["In practice, the SMT solver can often ",(0,t.jsx)(n.em,{children:"prove"})," correctness, but it often has problems with ",(0,t.jsx)(n.em,{children:"refutations"})," (i.e. providing counter-examples)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"z3-probes",children:"Z3 Probes"}),"\n",(0,t.jsxs)(n.p,{children:["Caesar supports the use of ",(0,t.jsxs)(n.a,{href:"https://microsoft.github.io/z3guide/docs/strategies/probes/",children:["Z3's ",(0,t.jsx)(n.em,{children:"probes"})]})," to quickly help you determine performance-relevant properties about the SMT query, such as the presence of quantifiers or the theoretical complexity of the problem."]}),"\n",(0,t.jsxs)(n.p,{children:["Run Caesar with the ",(0,t.jsx)(n.code,{children:"--probe"})," flag to enable probes.\nCaesar will print an output of the following form to standard error:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Probe results for test.heyvl::test:\nHas quantifiers: false\nDetected theories: NIRA\n - complexity: Undecidable\n - rejected theories: LRA, LIA, LIRA, NRA, NIA\nNumber of arithmetic constants: 1\nNumber of Boolean constants: 4\nNumber of bit-vector constants: 0\nNumber of constants: 1\nNumber of expressions: 71\n"})}),"\n",(0,t.jsxs)(n.p,{children:['The tool also tries to compute the complexity class of the problem to help you determine whether a problem is "easy".\nNote that none of these metrics can be used to conclusively determine whether a problem can be verified or not.\nFor example, the presence of quantifiers means that the problem can not be associated with a decidable fragment, but often times the SMT solver can still solve the problem.\nSimilarly, the number of expressions or constants can sometimes be useful indicators to ',(0,t.jsx)(n.em,{children:"compare"})," different problems, but on their own they are often not very informative.\nIn general, it is seldom useful to micro-optimize these metrics."]}),"\n",(0,t.jsx)(n.h3,{id:"z3-statistics",children:"Z3 Statistics"}),"\n",(0,t.jsxs)(n.p,{children:["With the ",(0,t.jsx)(n.code,{children:"--print-z3-stats"})," command-line flag, Caesar will print Z3 statistics to standard error."]}),"\n",(0,t.jsx)(n.h2,{id:"debugging-quantifier-instantiations",children:"Debugging Quantifier Instantiations"}),"\n",(0,t.jsx)(n.h3,{id:"function-encodings-and-limited-functions",children:"Function Encodings and Limited Functions"}),"\n",(0,t.jsxs)(n.p,{children:["Caesar supports many different encodings of ",(0,t.jsx)(n.a,{href:"/docs/heyvl/domains#definitional-functions",children:"definitional functions"}),", which can be selected via the ",(0,t.jsx)(n.code,{children:"--function-encoding"})," command-line option."]}),"\n",(0,t.jsxs)(n.p,{children:["The default is ",(0,t.jsx)(n.code,{children:"--function-encoding fuel-param"}),", which uses a ",(0,t.jsx)(n.em,{children:"fuel parameter"})," to limit how many times a function can be unfolded in the SMT query by the ",(0,t.jsx)(n.em,{children:"e-matching"})," quantifier instantiation strategy.\nFor example, a simple recursive definition of exponentials, ",(0,t.jsx)(n.code,{children:"exp(x)"})," will only be unfolded at most ",(0,t.jsx)(n.code,{children:"2"})," times (c.f. ",(0,t.jsx)(n.a,{href:"/docs/heyvl/domains#definitional-functions",children:"Definitional Functions"})," for a definition)."]}),"\n",(0,t.jsx)(n.p,{children:"Available function encodings:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"axiomatic"})}),": The most direct encoding with FO + uninterpreted functions, allowing for unbounded computations and arbitrary quantifier instantiations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"decreasing"})}),": Like axiomatic encoding but only allows decreasing instantiations, where the defining axiom is only instantiated based on occurrences of the function it defines, not other functions in the definition. These instantiations are unbounded."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fuel-mono"})}),": Add a version of the function for each fuel value (f_0, f_1, ...) and recursive calls decrease the fuel value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fuel-param"})})," (default): Add a symbolic fuel parameter to the function."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fuel-mono-computation"})}),": Like ",(0,t.jsx)(n.code,{children:"fuel-mono"}),", additionally allowing unbounded unfolding if the parameter values are literals."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fuel-param-computation"})}),": Like ",(0,t.jsx)(n.code,{children:"fuel-param"}),", additionally allowing unbounded unfolding if the parameter values are literals."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"define-fun-rec"})})," (alias: ",(0,t.jsx)(n.code,{children:"recfun"}),"): Uses ",(0,t.jsxs)(n.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Recursive%20Functions/",children:["SMT-LIB's ",(0,t.jsx)(n.code,{children:"define-fun-rec"})]})," to encode functions.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Does not translate SMT invariants like ",(0,t.jsx)(n.code,{children:"x >= 0"})," for ",(0,t.jsx)(n.code,{children:"UInt"}),"s into the definition, which ",(0,t.jsx)(n.em,{children:"might"})," over-constrain the function in very strange circumstances."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"literals",children:"Literals"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"fuel-mono-computation"})," and ",(0,t.jsx)(n.code,{children:"fuel-param-computation"})," encodings additionally allow unbounded unfolding if the parameter values are ",(0,t.jsx)(n.em,{children:"literals"}),".\nLiterals are expressions that do not contain variables.\nCaesar will also mark calls to ",(0,t.jsx)(n.em,{children:"definitional"})," functions with literal parameters as literals, so that e.g. ",(0,t.jsx)(n.code,{children:"exp(5)"})," is a literal and the definition of ",(0,t.jsx)(n.code,{children:"exp"})," can be unfolded as many times as needed.\nCalls to ",(0,t.jsx)(n.a,{href:"/docs/heyvl/domains#axiomatizing-uninterpreted-functions",children:"uninterpreted functions"})," are never considered literals, except when ",(0,t.jsxs)(n.a,{href:"/docs/heyvl/domains#computable-annotation",children:["annotated with the ",(0,t.jsx)(n.code,{children:"@computable"})," annotation"]}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"termination",children:"Termination"}),"\n",(0,t.jsxs)(n.p,{children:['Specific encodings can guarantee termination of the SMT query, which in practice means that we can quickly and stably obtain a result of either "verified", "counter-example found", or "unknown".\nTermination guarantees can only be given when using the ',(0,t.jsxs)(n.a,{href:"#selecting-quantifier-instantiation-strategies",children:[(0,t.jsx)(n.code,{children:"--quantifier-instantiation e-matching"})," command-line option"]})," (disabling MBQI)."]}),"\n",(0,t.jsx)(n.p,{children:"Then:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"axiomatic"})})," does not guarantee termination."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"decreasing"})})," guarantees termination only if the defined functions are terminating."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"fuel-mono"})," and ",(0,t.jsx)(n.code,{children:"fuel-mono-computation"})]})," guarantee termination."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"fuel-param"})," and ",(0,t.jsx)(n.code,{children:"fuel-param-computation"})]})," guarantee termination."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"define-fun-rec"})})," does not guarantee termination."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"no-synonym-axiom-option",children:"No Synonym Axiom Option"}),"\n",(0,t.jsxs)(n.p,{children:["Fuel-based encodings generate a ",(0,t.jsx)(n.em,{children:"synonym axiom"})," for each definitional function that specifies that all fuel versions of the function are equivalent.\nThe ",(0,t.jsx)(n.code,{children:"--no-synonym-axiom"})," command-line option can be used to disable the generation of the synonym axiom.\nThis might lead to ",(0,t.jsx)(n.em,{children:"spurious counter-examples"})," (unsound!), but sometimes this is acceptable or even desired."]}),"\n",(0,t.jsx)(n.h3,{id:"selecting-quantifier-instantiation-strategies",children:"Selecting Quantifier Instantiation Strategies"}),"\n",(0,t.jsxs)(n.p,{children:["You can select which strategies Z3 is allowed to use with Caesar's ",(0,t.jsx)(n.code,{children:"--quantifier-instantiation"})," command-line option.\nWhen restricting the quantifier instantiation to ",(0,t.jsx)(n.code,{children:"e-matching"}),", the fuel encodings guarantee termination of the SMT query.\nAvailable quantifier instantiation strategies:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"all"})})," (default): Use all available quantifier instantiation heuristics, in particular both e-matching and MBQI are enabled."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"e-matching"})}),": Only use E-matching for quantifier instantiation.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This disables MBQI; when using the fuel encodings, e-matching is guaranteed to terminate."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"mbqi"})}),": Only use ",(0,t.jsx)(n.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Quantifiers/#model-based-quantifier-instantiation",children:"MBQI"})," for quantifier instantiation."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"simple-qi-profiling",children:"Simple QI Profiling"}),"\n",(0,t.jsxs)(n.p,{children:["With Caesar's ",(0,t.jsx)(n.code,{children:"--z3-qi-profile"})," command-line flag, you can enable logging of quantifier instantiations.\nThis will enable ",(0,t.jsxs)(n.a,{href:"https://microsoft.github.io/z3guide/programming/Parameters/#smt",children:["Z3's ",(0,t.jsx)(n.code,{children:"smt.qi.profile"})," option"]}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Currently, this will print Z3's quantifier instantiation statistics to standard error every 1000 instantiations."}),"\n",(0,t.jsx)(n.p,{children:"The output will look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[quantifier_instances]    135-141 :     11 :   0 :   0 :   0 : 1\n[quantifier_instances] exp(return_invariant) :     57 :   0 :   0 :   3 : 4\n[quantifier_instances] exp(fuel_synonym) :     30 :   0 :   0 :   2 : 3\n[quantifier_instances] exp(definitional) :     30 :   0 :   0 :   2 : 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where the columns represent the following:",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-z3-qi-profile-docs",id:"user-content-fnref-z3-qi-profile-docs","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The quantifier instance name, e.g. ",(0,t.jsx)(n.code,{children:"exp(return_invariant)"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The number of instantiations of this quantifier."}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)("small",{children:"(always zero?)"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)("small",{children:"(always zero?)"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Maximum generation depth of the quantifier instantiation.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)("small",{children:["Let's say we have ",(0,t.jsx)(n.code,{children:"forall x . p(x) => p(x + 1)"}),", and ",(0,t.jsx)(n.code,{children:"p(0)"}),". Then ",(0,t.jsx)(n.code,{children:"p(1)"})," has generation 1, ",(0,t.jsx)(n.code,{children:"p(2)"})," has generation 2, etc."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Maximum cost of the quantifier instantiation."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mbqi-tracing",children:"MBQI Tracing"}),"\n",(0,t.jsxs)(n.p,{children:["When using MBQI, you can enable tracing of the quantifier instantiation process with the ",(0,t.jsx)(n.code,{children:"--z3-mbqi-trace"})," command-line flag.\nIt will enable Z3's ",(0,t.jsx)(n.code,{children:"smt.mbqi.trace"})," option, which will print a message before every round of MBQI."]}),"\n",(0,t.jsx)(n.h3,{id:"debugging-with-smtscope",children:"Debugging with SMTscope"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://viperproject.github.io/smt-scope/",children:"SMTscope tool"})," by the ",(0,t.jsx)(n.a,{href:"https://viper.ethz.ch/",children:"Viper project"})," can be used to debug quantifier instantiations in SMT queries.\nSMTscope is a graphical tool that allows you to visualize the quantifier instantiations that Z3 performs during the solving process.\nThis can be useful to understand why a query is taking a long time to solve or why it is not solving at all."]}),"\n",(0,t.jsxs)(n.p,{children:["To use SMTscope with Caesar, you need to run Caesar with the ",(0,t.jsx)(n.code,{children:"--z3-trace"})," flag.\nThis will create a ",(0,t.jsx)(n.code,{children:"z3.log"})," file in the current directory.\nLoad this file into SMTscope to visualize the quantifier instantiations."]}),"\n",(0,t.jsxs)(n.p,{children:["SMTscope's ",(0,t.jsx)(n.em,{children:"matching loop"})," detection is very useful.\nA matching loop occurs when Z3 repeatedly instantiates the same quantifier pattern.\nThis can be a sign that some quantifiers need additional ",(0,t.jsx)(n.a,{href:"/docs/heyvl/expressions#triggers",children:"triggers"})," to help Z3 find a solution."]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://dafny.org/dafny/DafnyRef/DafnyRef.html#sec-verification",children:"Dafny's guidelines for verification"})," can be helpful.\nMany of the ideas translate pretty much directly to Caesar."]}),"\n"]}),"\n","\n",(0,t.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,t.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{id:"user-content-fn-z3-qi-profile-docs",children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://microsoft.github.io/z3guide/programming/Parameters/#smt.qi.profile",children:["Z3's documentation on ",(0,t.jsx)(n.code,{children:"smt.qi.profile"})]})," is rather sparse. The description is based on the ",(0,t.jsxs)(n.a,{href:"https://github.com/Z3Prover/z3/blob/f77123c13cc8dabe8d1d0217a3312738da834eba/src/smt/smt_quantifier.cpp#L169-L189",children:["source code of ",(0,t.jsx)(n.code,{children:"smt_quantifier.cpp"})," of Z3"]})," and ",(0,t.jsx)(n.a,{href:"https://github.com/Z3Prover/z3/issues/4522#issuecomment-644454562",children:"this issue comment by Nikolaj Bjorner"}),". ",(0,t.jsx)(n.a,{href:"#user-content-fnref-z3-qi-profile-docs","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);