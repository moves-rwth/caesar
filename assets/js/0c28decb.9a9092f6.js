"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[3668],{2526:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"heyvl/domains","title":"Functions, Axioms, and Domains","description":"User-defined functions, both definitional and uninterpreted with equality (EUF).","source":"@site/docs/heyvl/domains.md","sourceDirName":"heyvl","slug":"/heyvl/domains","permalink":"/docs/heyvl/domains","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/domains.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"description":"User-defined functions, both definitional and uninterpreted with equality (EUF).","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Expressions","permalink":"/docs/heyvl/expressions"},"next":{"title":"Standard Library","permalink":"/docs/stdlib/"}}');var t=i(4848),s=i(8453);const a={description:"User-defined functions, both definitional and uninterpreted with equality (EUF).",sidebar_position:4},r="Functions, Axioms, and Domains",d={},l=[{value:"Definitional Functions",id:"definitional-functions",level:2},{value:"Axiomatizing Uninterpreted Functions",id:"axiomatizing-uninterpreted-functions",level:2},{value:"Computable Annotation",id:"computable-annotation",level:3},{value:"Axioms",id:"axioms",level:2},{value:"Axioms for Hints",id:"axioms-for-hints",level:3},{value:"Axioms as Assumptions",id:"axioms-as-assumptions",level:3},{value:"Axioms and Limited Functions",id:"axioms-and-limited-functions",level:3},{value:"Defining Types with Domains",id:"defining-types-with-domains",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",...(0,s.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"functions-axioms-and-domains",children:"Functions, Axioms, and Domains"})}),"\n",(0,t.jsx)(n.p,{children:"This section covers how to extend HeyVL with custom functionality through domains.\nDomains allow you to define your own functions and data types that can be used throughout your HeyVL programs.\nThis is useful for modeling operations or data structures that aren't built into the language."}),"\n",(0,t.jsxs)(n.p,{children:["Functions (",(0,t.jsx)(n.code,{children:"func"}),"s) and axioms are always contained inside ",(0,t.jsx)(n.code,{children:"domain"})," declarations.\nA ",(0,t.jsx)(n.code,{children:"domain"})," declaration is a way to group related functions and axioms together, and it also ",(0,t.jsx)(n.a,{href:"#defining-types-with-domains",children:"creates a new type"})," that can be used in HeyVL code."]}),"\n",(0,t.jsxs)(n.p,{children:["There are two ways to define ",(0,t.jsx)(n.code,{children:"func"}),"s:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#definitional-functions",children:"Definitional functions"})," with a body, which are preferred."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#axiomatizing-uninterpreted-functions",children:"Uninterpreted functions"})," without a body, which are more flexible but allow less optimizations."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.admonition,{title:"Incompleteness",type:"note",children:(0,t.jsxs)(n.p,{children:["Note that definitional functions and axioms with quantifiers quickly introduce ",(0,t.jsx)(n.em,{children:"incompleteness"})," of Caesar, making it unable to prove or disprove verification.\nRead the documentation section on ",(0,t.jsx)(n.a,{href:"/docs/caesar/debugging#incompleteness",children:"SMT Theories and Incompleteness"})," for more information."]})}),"\n",(0,t.jsxs)(n.p,{children:["Caesar does some limited dependency tracking to determine which functions, axioms, and domains to translate into the final SMT formula.\nIn essence, a declaration will be translated only if there is a sequence of declarations starting from the translated procedure that leads to it.",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-dependency-tracking",id:"user-content-fnref-dependency-tracking","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,t.jsx)(n.h2,{id:"definitional-functions",children:"Definitional Functions"}),"\n",(0,t.jsxs)(n.p,{children:["The preferred way to declare ",(0,t.jsx)(n.code,{children:"func"}),"s is to give a definition of the body with them."]}),"\n",(0,t.jsx)(n.p,{children:"Consider the following silly example, declaring a function for exponentials of \xbd."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"domain Exponentials {\n    func exp_05(exponent: UInt): UReal = ite(exponent == 0, 1, 0.5 * exp_05(exponent - 1))\n}\n\nproc ohfive_6() -> ()\n    pre ?(true)\n    post ?(exp_05(6) == 0.5 * 0.5 * 0.5 * 0.125)\n{}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The domain ",(0,t.jsx)(n.code,{children:"Exponentials"})," contains one func declaration ",(0,t.jsx)(n.code,{children:"exp_05"})," with one parameter, ",(0,t.jsx)(n.code,{children:"exponent"})," of type ",(0,t.jsx)(n.code,{children:"UInt"}),".\nIt returns a value of type ",(0,t.jsx)(n.code,{children:"UInt"}),", and its recursive definition is given after the equality sign."]}),"\n",(0,t.jsx)(n.admonition,{title:"Function Encodings",type:"note",children:(0,t.jsxs)(n.p,{children:["Caesar supports many different encodings of definitional functions, which can be selected via the ",(0,t.jsx)(n.code,{children:"--function-encoding"})," command-line option.\nThese can be used to tweak the SMT solver's reasoning and even guarantee termination of the underlying quantifier instantiation strategy.\n",(0,t.jsx)(n.a,{href:"/docs/caesar/debugging#function-encodings-and-limited-functions",children:"More information can be found in the debugging documentation"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"axiomatizing-uninterpreted-functions",children:"Axiomatizing Uninterpreted Functions"}),"\n",(0,t.jsxs)(n.p,{children:["The alternative to defining funcs with bodies is to define them ",(0,t.jsx)(n.em,{children:"uninterpreted"}),", that is, only defined by a bunch of axioms."]}),"\n",(0,t.jsx)(n.p,{children:"This is how the above example would look like then:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"domain Exponentials {\n    func exp_05(exponent: UInt): EUReal\n\n    axiom exp_05_base exp_05(0) == 1\n    axiom exp_05_step forall exponent: UInt. exp_05(exponent + 1) == 0.5 * exp_05(exponent)\n}\n\nproc ohfive_6() -> ()\n    pre ?(true)\n    post ?(exp_05(6) == 0.5 * 0.5 * 0.5 * 0.125)\n{}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, we do not specify a body for ",(0,t.jsx)(n.code,{children:"exp_05"}),".\nInstead, we give two axioms, with names ",(0,t.jsx)(n.code,{children:"exp_05_base"})," and ",(0,t.jsx)(n.code,{children:"exp_05_step"})," respectively, to define both cases.\nThe first axiom simply specifies that ",(0,t.jsx)(n.code,{children:"exp_05(0) == 1"})," holds (the base case), and the second one specifies that for all ",(0,t.jsx)(n.code,{children:"exponent"}),", we can equate ",(0,t.jsx)(n.code,{children:"exp_05(exponent + 1)"})," with ",(0,t.jsx)(n.code,{children:"0.5 * exp_05(exponent)"})," (inductive case)."]}),"\n",(0,t.jsxs)(n.p,{children:["This way of defining functions is more flexible than ",(0,t.jsx)(n.a,{href:"#definitional-functions",children:"definitional functions"}),", but Caesar cannot apply important optimizations this way.\nTherefore, definitional functions should always be preferred if possible."]}),"\n",(0,t.jsx)(n.h3,{id:"computable-annotation",children:"Computable Annotation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@computable"})," annotation should be used on uninterpreted functions which are computable when given ",(0,t.jsx)(n.em,{children:"literal"})," parameters.\nThis is only relevant when using the ",(0,t.jsxs)(n.a,{href:"/docs/caesar/debugging#function-encodings-and-limited-functions",children:[(0,t.jsx)(n.code,{children:"fuel-mono-computation"})," or ",(0,t.jsx)(n.code,{children:"fuel-param-computation"})," function encodings"]}),".\nThen, calls to uninterpreted functions ",(0,t.jsx)(n.em,{children:"inside definitional functions"})," with literal parameters are also considered literals, and the definitional function can be unfolded as many times as needed."]}),"\n",(0,t.jsx)(n.p,{children:"The annotation follows the definition, e.g.:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"domain Exponentials {\n    func exp_05(exponent: UInt): EUReal @computable\n    // ...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"axioms",children:"Axioms"}),"\n",(0,t.jsx)(n.h3,{id:"axioms-for-hints",children:"Axioms for Hints"}),"\n",(0,t.jsxs)(n.p,{children:["Axioms can be used for both definitional functions and for uninterpreted functions.\nFor example, the verifier might need to know the fact that ",(0,t.jsx)(n.code,{children:"exp_05(x) >= 1"})," always holds.\nWe can add the following axiom for both of the above definitions to let Caesar know this fact:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"axiom exp_05_one forall exponent: UInt. exp_05(exponent) >= 1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"axioms-as-assumptions",children:"Axioms as Assumptions"}),"\n",(0,t.jsxs)(n.p,{children:["One can see any axiom simply as an ",(0,t.jsxs)(n.a,{href:"/docs/heyvl/statements",children:[(0,t.jsx)(n.code,{children:"(co)assume"})," statement"]})," added before the procedure to be verified.\nFor example,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"axiom exp_05_step forall exponent: UInt. exp_05(exponent + 1) == 0.5 * exp_05(exponent)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["can be written via an ",(0,t.jsx)(n.code,{children:"assume"})," in just the same way:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"assume ?(forall exponent: UInt. exp_05(exponent + 1) == 0.5 * exp_05(exponent))\n"})}),"\n",(0,t.jsxs)(n.admonition,{title:"Unsoundness from Axioms",type:"warning",children:[(0,t.jsxs)(n.p,{children:["Because axiom declarations behave like ",(0,t.jsx)(n.code,{children:"assume"})," statements, they can introduce unsoundness in the same way."]}),(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Example for unsoundness from axioms."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"domain Unsound {\n    func f(): Bool\n    axiom unsound false && f()\n}\n\nproc wrong() -> ()\n    pre ?(true)\n    post ?(true)\n{\n    assert ?(false && f())\n}\n"})}),(0,t.jsxs)(n.p,{children:["The axiom ",(0,t.jsx)(n.code,{children:"unsound"})," always evaluates to ",(0,t.jsx)(n.code,{children:"false"}),".\nBut for verification, Caesar assumes the axioms hold for all program states.\nIn other words, Caesar only verifies the program states in which the axioms evaluate to ",(0,t.jsx)(n.code,{children:"true"}),".\nThus, Caesar does not verify any program state and the procedure ",(0,t.jsx)(n.code,{children:"wrong"})," incorrectly verifies!"]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"axioms-and-limited-functions",children:"Axioms and Limited Functions"}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.a,{href:"/docs/caesar/debugging#function-encodings-and-limited-functions",children:"limited functions"}),", calls inside axioms have to be defined with respect to a certain ",(0,t.jsx)(n.em,{children:"fuel"})," value, i.e. how many unfoldings of the function are allowed."]}),"\n",(0,t.jsxs)(n.p,{children:["At the moment, Caesar will ",(0,t.jsx)(n.em,{children:"only"})," define the axiom with one specific fuel value, which is the maximum defined by the ",(0,t.jsx)(n.code,{children:"--max-fuel"})," command-line option (default: 2).\nFor example, the axiom from above would be translated to:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"axiom exp_05_one forall exponent: UInt. exp_05($S($S($Z)), exponent) >= 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"$S($S($Z))"})," represents the fuel value of 2.\nThis behavior has implications with respect to ",(0,t.jsx)(n.a,{href:"/docs/heyvl/expressions#triggers",children:"triggers"}),": the quantifier will only be instantiated by e-matching for the specific fuel value of 2."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-types-with-domains",children:"Defining Types with Domains"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"domain"})," declaration always creates a new uninterpreted type that can also be axiomatized."]}),"\n",(0,t.jsxs)(n.p,{children:["Every domain type supports the binary operators ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"!="}),".\nAll other operations must be encoded using functions and axioms."]}),"\n",(0,t.jsxs)(n.p,{children:["The following example declares a ",(0,t.jsx)(n.code,{children:"Tree"})," type with left and right branches, and where each leaf has a value of type ",(0,t.jsx)(n.code,{children:"Int"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"domain Tree {\n    func leaf(value: Int): Tree\n    func node(left: Tree, right: Tree): Tree\n\n    func is_leaf(tree: Tree): Bool\n    axiom is_leaf_leaf forall value: Int. is_leaf(leaf(value)) == true\n    axiom is_leaf_node forall t1: Tree, t2: Tree. is_leaf(node(t1, t2)) == false\n\n    func get_value(tree: Tree): Int\n    axiom get_value_def forall value: Int. get_value(leaf(value)) == value\n}\n"})}),"\n","\n",(0,t.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,t.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{id:"user-content-fn-dependency-tracking",children:["\n",(0,t.jsxs)(n.p,{children:["An axiom like ",(0,t.jsx)(n.code,{children:"axiom unsound false"})," would never be translated by Caesar, because it does not mention any other declarations.\nTherefore, Caesar will throw an error on such axioms. ",(0,t.jsx)(n.a,{href:"#user-content-fnref-dependency-tracking","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var o=i(6540);const t={},s=o.createContext(t);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);