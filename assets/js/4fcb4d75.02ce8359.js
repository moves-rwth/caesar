"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[2762],{941:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"caesar/debugging","title":"Debugging","description":"Follow this guide if you are debugging verification with Caesar.","source":"@site/docs/caesar/debugging.md","sourceDirName":"caesar","slug":"/caesar/debugging","permalink":"/docs/caesar/debugging","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/caesar/debugging.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"The Caesar Tool","permalink":"/docs/caesar/"},"next":{"title":"VSCode Extension & LSP Support","permalink":"/docs/caesar/vscode-and-lsp"}}');var n=t(4848),r=t(8453);const o={sidebar_position:1},a="Debugging",c={},l=[{value:"SMT Theories and Incompleteness",id:"incompleteness",level:2},{value:"Z3 Probes",id:"z3-probes",level:3},{value:"Z3 Statistics",id:"z3-statistics",level:3},{value:"Debugging Quantifier Instantiations with SMTscope",id:"debugging-quantifier-instantiations-with-smtscope",level:2},{value:"Further Reading",id:"further-reading",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"debugging",children:"Debugging"})}),"\n",(0,n.jsx)(i.p,{children:"Follow this guide if you are debugging verification with Caesar."}),"\n",(0,n.jsx)(i.h2,{id:"incompleteness",children:"SMT Theories and Incompleteness"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"/docs/heyvl/expressions",children:"Expressions"})," are the main reason for ",(0,n.jsx)(i.em,{children:"incompleteness"})," of Caesar, i.e. instances Caesar is unable to decide whether a given HeyVL program verifies or not.\nCaesar's incompleteness comes from incompleteness of the underlying SMT solver which is used to prove or disprove verification."]}),"\n",(0,n.jsxs)(i.p,{children:["At the moment, Caesar's translation of HeyVL verification problems is rather direct: most expressions are translated as one would intuitively expect.\nIf operators have a direct correspondence in ",(0,n.jsx)(i.a,{href:"https://smt-lib.org/",children:"SMT-LIB"}),", then we translate directly to those.\nOtherwise, usually only additional simple case distinctions are introduced.\nWe have some more explanations in ",(0,n.jsx)(i.a,{href:"https://arxiv.org/pdf/2309.07781#page=23",children:"Section 5 of our paper on HeyVL"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["As a consequence, it is usually pretty simple to predict which ",(0,n.jsx)(i.a,{href:"https://smt-lib.org/theories.shtml",children:"SMT-LIB theories"})," will be used for the SMT query done by Caesar.\n",(0,n.jsx)(i.a,{href:"#z3-probes",children:"Caesar supports Z3 probes"})," to help you check in which theory your problem falls.\nAlso refer to the ",(0,n.jsx)(i.a,{href:"https://microsoft.github.io/z3guide/docs/theories/Arithmetic/",children:"Z3 documentation on arithmetic theories"}),", since a lot of Caesar's reasoning will need arithmetic."]}),"\n",(0,n.jsx)(i.p,{children:"Here are some rules of thumb for (in-)completeness:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Linear integer and real arithmetic (QF_LRA, QF_LIRA) is decidable."}),"\n",(0,n.jsx)(i.li,{children:"Nonlinear integer arithmetic (QF_NIA) is undecidable."}),"\n",(0,n.jsx)(i.li,{children:"Nonlinear real arithmetic (QF_NRA) is decidable for algebraic reals."}),"\n",(0,n.jsxs)(i.li,{children:["Quantifiers usually introduce undecidability, although there are ",(0,n.jsx)(i.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Quantifiers#model-based-quantifier-instantiation",children:"a bunch of strategies and fragments in Z3 that allow decidability"}),".","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["In particular, restrictive ",(0,n.jsx)(i.a,{href:"/docs/heyvl/expressions#triggers",children:"quantifier triggers"})," can help e-matching prove many instances."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["HeyVL's ",(0,n.jsx)(i.a,{href:"/docs/heyvl/expressions#quantifiers",children:"quantitative quantifiers"})," (",(0,n.jsx)(i.code,{children:"inf"})," and ",(0,n.jsx)(i.code,{children:"sup"}),") currently have a very naive default encoding that is problematic for Z3.  If the quantitative quantifiers cannot be eliminated by Caesar's quantifier elimination (QE) procedure, then they are often a cause of nontermination of Caesar.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Quantitative quantifiers also come from the semantics of ",(0,n.jsxs)(i.a,{href:"/docs/heyvl/statements#havoc",children:[(0,n.jsx)(i.code,{children:"havoc"})," and ",(0,n.jsx)(i.code,{children:"cohavoc"})]}),". However, for e.g. the ",(0,n.jsx)(i.a,{href:"/docs/proof-rules/induction",children:"induction-based proof rules"}),", the HeyVL encodings fall into a fragment where Caesar's QE applies and the generated quantifiers are eliminated."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["In practice, the SMT solver can often ",(0,n.jsx)(i.em,{children:"prove"})," correctness, but it often has problems with ",(0,n.jsx)(i.em,{children:"refutations"})," (i.e. providing counter-examples)."]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"z3-probes",children:"Z3 Probes"}),"\n",(0,n.jsxs)(i.p,{children:["Caesar supports the use of ",(0,n.jsxs)(i.a,{href:"https://microsoft.github.io/z3guide/docs/strategies/probes/",children:["Z3's ",(0,n.jsx)(i.em,{children:"probes"})]})," to quickly help you determine performance-relevant properties about the SMT query, such as the presence of quantifiers or the theoretical complexity of the problem."]}),"\n",(0,n.jsxs)(i.p,{children:["Run Caesar with the ",(0,n.jsx)(i.code,{children:"--probe"})," flag to enable probes.\nCaesar will print an output of the following form to standard error:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"Probe results for test.heyvl::test:\nHas quantifiers: false\nDetected theories: NIRA\n - complexity: Undecidable\n - rejected theories: LRA, LIA, LIRA, NRA, NIA\nNumber of arithmetic constants: 1\nNumber of Boolean constants: 4\nNumber of bit-vector constants: 0\nNumber of constants: 1\nNumber of expressions: 71\n"})}),"\n",(0,n.jsxs)(i.p,{children:['The tool also tries to compute the complexity class of the problem to help you determine whether a problem is "easy".\nNote that none of these metrics can be used to conclusively determine whether a problem can be verified or not.\nFor example, the presence of quantifiers means that the problem can not be associated with a decidable fragment, but often times the SMT solver can still solve the problem.\nSimilarly, the number of expressions or constants can sometimes be useful indicators to ',(0,n.jsx)(i.em,{children:"compare"})," different problems, but on their own they are often not very informative.\nIn general, it is seldom useful to micro-optimize these metrics."]}),"\n",(0,n.jsx)(i.h3,{id:"z3-statistics",children:"Z3 Statistics"}),"\n",(0,n.jsxs)(i.p,{children:["With the ",(0,n.jsx)(i.code,{children:"--print-z3-stats"})," command-line flag, Caesar will print Z3 statistics to standard error."]}),"\n",(0,n.jsx)(i.h2,{id:"debugging-quantifier-instantiations-with-smtscope",children:"Debugging Quantifier Instantiations with SMTscope"}),"\n",(0,n.jsxs)(i.p,{children:["The ",(0,n.jsx)(i.a,{href:"https://viperproject.github.io/smt-scope/",children:"SMTscope tool"})," by the ",(0,n.jsx)(i.a,{href:"https://viper.ethz.ch/",children:"Viper project"})," can be used to debug quantifier instantiations in SMT queries.\nSMTscope is a graphical tool that allows you to visualize the quantifier instantiations that Z3 performs during the solving process.\nThis can be useful to understand why a query is taking a long time to solve or why it is not solving at all."]}),"\n",(0,n.jsxs)(i.p,{children:["To use SMTscope with Caesar, you need to run Caesar with the ",(0,n.jsx)(i.code,{children:"--z3-trace"})," flag.\nThis will create a ",(0,n.jsx)(i.code,{children:"z3.log"})," file in the current directory.\nLoad this file into SMTscope to visualize the quantifier instantiations."]}),"\n",(0,n.jsxs)(i.p,{children:["SMTscope's ",(0,n.jsx)(i.em,{children:"matching loop"})," detection is very useful.\nA matching loop occurs when Z3 repeatedly instantiates the same quantifier pattern.\nThis can be a sign that some quantifiers need additional ",(0,n.jsx)(i.a,{href:"/docs/heyvl/expressions#triggers",children:"triggers"})," to help Z3 find a solution."]}),"\n",(0,n.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://dafny.org/dafny/DafnyRef/DafnyRef.html#sec-verification",children:"Dafny's guidelines for verification"})," can be helpful.\nMany of the ideas translate pretty much directly to Caesar."]}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>a});var s=t(6540);const n={},r=s.createContext(n);function o(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);