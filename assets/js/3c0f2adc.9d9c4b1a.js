"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[9083],{983:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"proof-rules/induction","title":"Induction and k-Induction","description":"Induction and k-Induction are proof rules for while loops.","source":"@site/docs/proof-rules/induction.md","sourceDirName":"proof-rules","slug":"/proof-rules/induction","permalink":"/docs/proof-rules/induction","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/proof-rules/induction.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"Induction and k-Induction are proof rules for while loops.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Calculus Annotations","permalink":"/docs/proof-rules/calculi"},"next":{"title":"Loop Unrolling","permalink":"/docs/proof-rules/unrolling"}}');var t=o(4848),r=o(8453);const s={description:"Induction and k-Induction are proof rules for while loops.",sidebar_position:2},c="Induction and k-Induction",a={},l=[{value:"Usage",id:"usage",level:2},{value:"Soundness",id:"soundness",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"induction-and-k-induction",children:"Induction and k-Induction"})}),"\n",(0,t.jsxs)(n.p,{children:["TLDR: Probabilistic induction generalizes the well-known ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hoare_logic#While_rule",children:"proof rule for loops from Hoare logic"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Induction"})," and the more general ",(0,t.jsx)(n.em,{children:"k-Induction"})," are built-in proof rules to reason about ",(0,t.jsx)(n.code,{children:"while"})," loops.\nThe non-probabilistic intuitions go as follows: induction requires an ",(0,t.jsx)(n.em,{children:"invariant"})," that is maintained by each loop iteration.\nIt must hold before the loop, and then we are guaranteed that the invariant holds after the loop.\n",(0,t.jsx)(n.em,{children:"k"}),"-induction allows us to reason about multiple loop iterations: the invariant is not required to be re-established after just one loop iteration, but may be re-established after ",(0,t.jsx)(n.code,{children:"1"}),", ",(0,t.jsx)(n.code,{children:"2"}),", ..., up to ",(0,t.jsx)(n.code,{children:"k"})," loop iterations."]}),"\n",(0,t.jsxs)(n.p,{children:["HeyVL supports the lattice-theoretic generalizations of these rules.\nSee ",(0,t.jsx)(n.a,{href:"https://link.springer.com/chapter/10.1007/978-3-030-81688-9_25",children:(0,t.jsx)(n.em,{children:"Latticed k-Induction with an Application to Probabilistic Programs"})})," (CAV 2021) for more information on the theory.\nCaesar will use the formulation from that paper only for upper-bounds reasoning (",(0,t.jsx)(n.code,{children:"coproc"}),"s) because it is associated with least fixed-point reasoning that the paper also deals with.\nFor lower-bounds reasoning (",(0,t.jsx)(n.code,{children:"proc"}),"s), Caesar will use a dual encoding that is sound with respect to greatest fixed-point semantics.\nFormal details are provided in Appendix C of the ",(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2309.07781",children:"extended version of our OOPSLA '23 paper"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["To use ",(0,t.jsx)(n.em,{children:"induction"}),", simply add an ",(0,t.jsx)(n.code,{children:"@invariant(I)"})," annotation to your loop with a probabilistic invariant ",(0,t.jsx)(n.code,{children:"I"}),".\nIn this case, it is ",(0,t.jsx)(n.code,{children:"ite(cont, c + 1, c)"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"coproc geo1_induction(init_c: UInt) -> (c: UInt)\n    pre init_c + 1\n    post c\n{\n    c = init_c\n    var cont: Bool = true\n    @invariant(ite(cont, c + 1, c))\n    while (cont) {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To use ",(0,t.jsx)(n.em,{children:"k-induction"}),", you can use the ",(0,t.jsx)(n.code,{children:"@k_induction(k, I)"})," annotation on a loop.\nIt takes two parameters: The number literal ",(0,t.jsx)(n.code,{children:"k"})," specifies the number of unrollings are to be done and ",(0,t.jsx)(n.code,{children:"I"})," is the invariant."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"coproc geo1_2induction(init_c: UInt) -> (c: UInt)\n    pre init_c + 1\n    post c\n{\n    c = init_c\n    var cont: Bool = true\n    @k_induction(2, c + 1)\n    while cont {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This program will not verify if ",(0,t.jsx)(n.code,{children:"k"})," is set to ",(0,t.jsx)(n.code,{children:"1"})," because the invariant ",(0,t.jsx)(n.code,{children:"c + 1"})," is not 1-inductive."]}),"\n",(0,t.jsx)(n.h2,{id:"soundness",children:"Soundness"}),"\n",(0,t.jsxs)(n.p,{children:["Using these proof rules is always ",(0,t.jsx)(n.em,{children:"sound"})," in the following way: Both annotations will always ",(0,t.jsx)(n.em,{children:"under-approximate greatest fixed-point"})," semantics when used in lower-bound contexts (",(0,t.jsx)(n.code,{children:"proc"}),") and ",(0,t.jsx)(n.em,{children:"over-approximate  least fixed-point"})," loop semantics when used in upper-bound contexts (",(0,t.jsx)(n.code,{children:"coproc"}),").\nThe ",(0,t.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"calculus annotations"})," can help you make sure you are doing the right thing."]}),"\n",(0,t.jsxs)(n.p,{children:["If the invariants are not ",(0,t.jsx)(n.em,{children:"inductive"})," in some initial state, i.e. are not maintained by the loop iteration(s), then the encodings will evaluate to ",(0,t.jsx)(n.code,{children:"0"})," or ",(0,t.jsx)(n.code,{children:"\\infty"})," (",(0,t.jsx)(n.code,{children:"proc"})," and ",(0,t.jsx)(n.code,{children:"coproc"}),", respectively) for that initial state."]}),"\n",(0,t.jsxs)(n.p,{children:["Again, formal details are provided in Appendix C of the ",(0,t.jsx)(n.a,{href:"https://arxiv.org/abs/2309.07781",children:"extended version of our OOPSLA '23 paper"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>c});var i=o(6540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);