"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[41],{302:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/05/23/caesar-2-2","editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/blog/2025-05-23-caesar-2-2.md","source":"@site/blog/2025-05-23-caesar-2-2.md","title":"Caesar 2.2: Timeout Handling, Recursion Checks, Improved Model Checking, and More","description":"The Caesar 2.2 is an incremental release that adds various improvements to existing features and fixes some bugs.","date":"2025-05-23T00:00:00.000Z","tags":[{"inline":true,"label":"releases","permalink":"/blog/tags/releases"}],"readingTime":2.67,"hasTruncateMarker":true,"authors":[{"name":"Philipp Schroer","title":"Caesar Developer","url":"https://moves.rwth-aachen.de/people/philipp-schroer/","imageURL":"https://github.com/Philipp15b.png","key":"phisch","page":null}],"frontMatter":{"authors":"phisch","tags":["releases"]},"unlisted":false,"prevItem":{"title":"Caesar at Summer School for Formal Techniques \'25","permalink":"/blog/2025/06/10/caesar-at-ssft-25"},"nextItem":{"title":"Foundations for Verification of Continuous Programs with Caesar","permalink":"/blog/2025/04/11/foundations-continuous"}}')},6547:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=r(302),i=r(4848),a=r(8453);const o={authors:"phisch",tags:["releases"]},t="Caesar 2.2: Timeout Handling, Recursion Checks, Improved Model Checking, and More",l={authorsImageUrls:[void 0]},c=[{value:"UI Improvements",id:"ui-improvements",level:2},{value:"Guardrail Against Unsound Recursion",id:"guardrail-against-unsound-recursion",level:2},{value:"Better Model Checking Support",id:"model-checking",level:2},{value:"AST Rule Improvements",id:"ast-rule",level:2},{value:"Other Changes",id:"other-changes",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"Caesar 2.2"})," is an incremental release that adds various improvements to existing features and fixes some bugs."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Overview:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/05/23/caesar-2-2#ui-improvements",children:"UI Improvements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/05/23/caesar-2-2#guardrail-against-unsound-recursion",children:"Guardrail Against Unsound Recursion"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/05/23/caesar-2-2#model-checking",children:"Better Model Checking Support"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/05/23/caesar-2-2#ast-rule",children:"AST Rule Improvements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/05/23/caesar-2-2#other-changes",children:"Other Changes"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"ui-improvements",children:"UI Improvements"}),"\n",(0,i.jsx)(n.p,{children:"We have improved Caesar's LSP server and the Visual Studio Code extension."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The extension now properly handles Caesar timeouts."}),"\n",(0,i.jsx)(n.li,{children:"Gutter icons are now shown for more verification statuses (todo, ongoing, timeout)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"On the command-line:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Caesar now supports the ",(0,i.jsx)(n.code,{children:"--filter [<filter>]"})," command-line argument to filter the (co)procs that are to be verified or translated for model checking."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"guardrail-against-unsound-recursion",children:"Guardrail Against Unsound Recursion"}),"\n",(0,i.jsxs)(n.p,{children:["We have added a new check to prevent unsound recursion in the ",(0,i.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"calculus annotations"})," feature.\nThis check ensures that users do not accidentally invoke Park induction in an unsound way in the presence of recursive (co)procedures.\nIt is based on a call graph analysis of the program and over-approximates potential recursion."]}),"\n",(0,i.jsx)(n.h2,{id:"model-checking",children:"Better Model Checking Support"}),"\n",(0,i.jsxs)(n.p,{children:["Caesar's support for ",(0,i.jsx)(n.a,{href:"/docs/model-checking",children:"model checking"})," has been greatly improved in this release.\nFirst of all, it gained a new subcommand ",(0,i.jsx)(n.code,{children:"caesar mc"})," to run the model checker on a given HeyVL file."]}),"\n",(0,i.jsx)(n.p,{children:"Many bugs have been fixed and improvements have been made to the model checking support:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Correct extraction of preconditions from ",(0,i.jsx)(n.code,{children:"coproc"}),"s."]}),"\n",(0,i.jsx)(n.li,{children:"Support non-integer rewards."}),"\n",(0,i.jsx)(n.li,{children:"Support for different behaviours of uninitialized variables in the translation has been added."}),"\n",(0,i.jsxs)(n.li,{children:["Support for translation of more verification statements (specific forms of ",(0,i.jsx)(n.code,{children:"assume"}),", ",(0,i.jsx)(n.code,{children:"assert"}),") has been added."]}),"\n",(0,i.jsx)(n.li,{children:"Only required function definitions are now included in the translation."}),"\n",(0,i.jsx)(n.li,{children:"Caesar now supports directly invoking the Storm model checker via either an installed binary or by using a Docker image."}),"\n",(0,i.jsx)(n.li,{children:"Input variables can be translated as variables or as constants now."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"ast-rule",children:"AST Rule Improvements"}),"\n",(0,i.jsxs)(n.p,{children:["We have updated the ",(0,i.jsx)(n.a,{href:"/docs/proof-rules/ast#new-proof-rule",children:'"New Proof Rule for AST"'})," to be more general, allowing verification of AST for more programs.\nThis is a result of a combination of different formulations in the literature, our own theoretical improvements, as well as internal code improvements for the implementation."]}),"\n",(0,i.jsxs)(n.p,{children:["We have added ",(0,i.jsx)(n.a,{href:"/docs/proof-rules/ast",children:"new documentation"})," for general AST proofs and for this specific AST proof rule in particular."]}),"\n",(0,i.jsx)(n.h2,{id:"other-changes",children:"Other Changes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Documentation has been improved in many places."}),"\n",(0,i.jsx)(n.li,{children:"Caesar now supports Z3's probes to determine theoretical complexities of verification tasks."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Many internal improvements to the slicing algorithms have been made."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Improved robustness against Z3's incremental mode instabilities."}),"\n",(0,i.jsxs)(n.li,{children:["Fixed the ",(0,i.jsx)(n.code,{children:"sus"})," algorithm not finding optimal slices with non-extensive statements."]}),"\n",(0,i.jsx)(n.li,{children:"Clarified minimality guarantees of the different algorithms."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Internal:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Caesar's test files have been updated to consistenly use the built-in proof rules instead using the old Python-generated HeyVL encodings."}),"\n",(0,i.jsx)(n.li,{children:"Caesar has been updated to compile with latest versions of backwards-incompatible C++ compilers and new versions of CMake."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>t});var s=r(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);