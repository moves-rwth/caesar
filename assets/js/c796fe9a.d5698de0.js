"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[6881],{8661:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"heyvl/procs","title":"Procedures","description":"Procedures are HeyVL\'s logical units of code.","source":"@site/docs/heyvl/procs.md","sourceDirName":"heyvl","slug":"/heyvl/procs","permalink":"/docs/heyvl/procs","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/procs.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Procedures","description":"Procedures are HeyVL\'s logical units of code.","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"HeyVL","permalink":"/docs/heyvl/"},"next":{"title":"Statements","permalink":"/docs/heyvl/statements"}}');var o=n(4848),t=n(8453);const i={title:"Procedures",description:"Procedures are HeyVL's logical units of code.",sidebar_position:1},c="Procedures and Coprocedures",d={},a=[{value:"Example",id:"example",level:2},{value:"Verification of Procedures",id:"verification-of-procedures",level:2},{value:"Verification Encoding Internals",id:"verification-encoding-internals",level:3},{value:"Calling Procedures",id:"calling-procedures",level:2},{value:"Procedure Call Internals",id:"procedure-call-internals",level:3}];function l(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"procedures-and-coprocedures",children:"Procedures and Coprocedures"})}),"\n",(0,o.jsxs)(s.p,{children:["HeyVL ",(0,o.jsx)(s.a,{href:"/docs/heyvl/statements",children:"statements"})," are placed inside the body of ",(0,o.jsx)(s.em,{children:"(co)procedures"})," or ",(0,o.jsx)(s.em,{children:"(co)procs"})," for short.\nA ",(0,o.jsx)(s.em,{children:"procedure"})," has a name, a list of parameters, a list of return values, and a list of specification attributes.\nCaesar tries to verify each procedure in the given HeyVL files using the specification.\n",(0,o.jsx)(s.em,{children:"Coprocedures"})," are like procedures, but the specification is interpreted differently (see below)."]}),"\n",(0,o.jsx)(s.p,{children:"Procedures can be called inside other procedures.\nThis enables modular reasoning about code: Prove that some code satisfies the specification once, and then use the specification when at the call site - without reasoning about the procedure's body again."}),"\n",(0,o.jsx)(s.p,{children:"There are also procedures without an associated body.\nThey are not verified by Caesar, but can be called inside other procedures."}),"\n",(0,o.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,o.jsxs)(s.p,{children:["The following procedure named ",(0,o.jsx)(s.code,{children:"forty_two"})," accepts a single parameter, ",(0,o.jsx)(s.code,{children:"x"})," of type ",(0,o.jsx)(s.code,{children:"UInt"})," and returns a value ",(0,o.jsx)(s.code,{children:"y"})," of type ",(0,o.jsx)(s.code,{children:"UInt"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-heyvl",children:"proc forty_two(x: UInt) -> (y: UInt)\n    pre ?(x == 41)\n    post ?(y == 42)\n{\n    y = x + 1;\n}\n"})}),"\n",(0,o.jsxs)(s.p,{children:["There are two specification attributes: ",(0,o.jsx)(s.code,{children:"pre"})," and ",(0,o.jsx)(s.code,{children:"post"}),".\nIntuitively, both attributes assert that if ",(0,o.jsx)(s.code,{children:"forty_two"})," is called with ",(0,o.jsx)(s.code,{children:"x == 41"}),", the result ",(0,o.jsx)(s.code,{children:"y"})," will have value ",(0,o.jsx)(s.code,{children:"42"}),".\nThe expressions inside the ",(0,o.jsx)(s.code,{children:"pre"})," and ",(0,o.jsx)(s.code,{children:"post"})," statements are expectations, i.e. have type ",(0,o.jsx)(s.a,{href:"/docs/stdlib/numbers#eureal",children:(0,o.jsx)(s.code,{children:"EUReal"})}),".\nWe use ",(0,o.jsx)(s.a,{href:"/docs/heyvl/expressions",children:"embed expressions"})," to convert Boolean expressions to ",(0,o.jsx)(s.code,{children:"EUReal"})," values.\nThe procedure has a body with just a single assignment statement that increments ",(0,o.jsx)(s.code,{children:"x"})," by 1 and saves the result in ",(0,o.jsx)(s.code,{children:"y"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["Writing ",(0,o.jsx)(s.code,{children:"coproc"})," instead of ",(0,o.jsx)(s.code,{children:"proc"})," will will do an upper bound check for verification instead of a lower bound one."]}),"\n",(0,o.jsxs)(s.p,{children:["The specification is optional; if it's not provided, Caesar will add a default specification: ",(0,o.jsx)(s.code,{children:"pre ?(true)"})," and ",(0,o.jsx)(s.code,{children:"post ?(true)"})," for procedures and ",(0,o.jsx)(s.code,{children:"pre ?(false)"})," and ",(0,o.jsx)(s.code,{children:"post ?(false)"})," for coprocedures."]}),"\n",(0,o.jsx)(s.h2,{id:"verification-of-procedures",children:"Verification of Procedures"}),"\n",(0,o.jsx)(s.p,{children:"If a procedure has a body with statements, then Caesar will try to verify the procedure based on the specification attributes.\nThe verificiation of procedures can be entirely framed as a verification of HeyVL statements."}),"\n",(0,o.jsx)(s.h3,{id:"verification-encoding-internals",children:"Verification Encoding Internals"}),"\n",(0,o.jsxs)(s.p,{children:["To verify the ",(0,o.jsx)(s.code,{children:"forty_two"})," procedure, Caesar generates the following HeyVL statements:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-heyvl",children:"assume ?(x == 41)\ny = x + 1;\nassert ?(y == 42)\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Each ",(0,o.jsx)(s.code,{children:"pre"})," attribute generates an ",(0,o.jsx)(s.code,{children:"assume"}),"/",(0,o.jsx)(s.code,{children:"coassume"})," statement at the beginning.\nThen the unmodified procedure body follows.\nAfter that, an ",(0,o.jsx)(s.code,{children:"assert"}),"/",(0,o.jsx)(s.code,{children:"coassert"})," statement is generated for each ",(0,o.jsx)(s.code,{children:"post"})," attribute."]}),"\n",(0,o.jsxs)(s.p,{children:["For coprocedures, the generated HeyVL statements will be preceded by a ",(0,o.jsx)(s.code,{children:"negate"})," and ended by a ",(0,o.jsx)(s.code,{children:"conegate"})," statement."]}),"\n",(0,o.jsx)(s.h2,{id:"calling-procedures",children:"Calling Procedures"}),"\n",(0,o.jsx)(s.p,{children:"Procedures can be called inside other procedures.\nJust like for the verification task, a call of a procedure is replaced by a sequence of HeyVL statements based on the specification."}),"\n",(0,o.jsx)(s.h3,{id:"procedure-call-internals",children:"Procedure Call Internals"}),"\n",(0,o.jsxs)(s.p,{children:["A call to ",(0,o.jsx)(s.code,{children:"forty_two"}),", e.g. ",(0,o.jsx)(s.code,{children:"y = forty_two(x);"})," is replaced by three basic HeyVL statements:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-heyvl",children:"assert ?(x == 41)\nhavoc y\nvalidate\nassume ?(y == 42)\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Now we ",(0,o.jsx)(s.code,{children:"assert"})," each ",(0,o.jsx)(s.code,{children:"pre"})," to ensure that the preceding code has actually established the pre-condition.\nThen we ",(0,o.jsx)(s.code,{children:"havoc"})," the modified variable ",(0,o.jsx)(s.code,{children:"y"}),".\nAt this point, we know nothing about the value of ",(0,o.jsx)(s.code,{children:"y"}),".\nAt the end, we ",(0,o.jsx)(s.code,{children:"assume"})," the expression from the ",(0,o.jsx)(s.code,{children:"post"})," attribute.\nNow we know ",(0,o.jsx)(s.code,{children:"y"})," has value ",(0,o.jsx)(s.code,{children:"42"}),".\nThe ",(0,o.jsx)(s.code,{children:"validate"})," statement is necessary to encode a Boolean check against the post."]}),"\n",(0,o.jsxs)(s.p,{children:["The body of the procedure is not used to encode a procedure call.\nThis is why it is also possible to declare ",(0,o.jsx)(s.code,{children:"forty_two"})," without an associated body, but still call it inside another procedure."]}),"\n",(0,o.jsxs)(s.p,{children:["You can find more details in our ",(0,o.jsx)(s.a,{href:"/docs/publications#oopsla-23",children:"OOPLSA '23 paper"}),"."]}),"\n",(0,o.jsx)(s.admonition,{type:"caution",children:(0,o.jsx)(s.p,{children:"Right now, you can call procedures inside coprocedures and vice-versa.\nThis is basically never sound.\nWe'll fix that soon."})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>c});var r=n(6540);const o={},t=r.createContext(o);function i(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);