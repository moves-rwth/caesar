"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[3805],{4033:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"proof-rules/calculi","title":"Calculus Annotations","description":"Procedure annotations for soundness of proof rules.","source":"@site/docs/proof-rules/calculi.md","sourceDirName":"proof-rules","slug":"/proof-rules/calculi","permalink":"/docs/proof-rules/calculi","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/proof-rules/calculi.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"Procedure annotations for soundness of proof rules."},"sidebar":"docsSidebar","previous":{"title":"Proof Rules","permalink":"/docs/proof-rules/"},"next":{"title":"Induction and k-Induction","permalink":"/docs/proof-rules/induction"}}');var r=s(4848),i=s(8453),t=s(8774);const c={sidebar_position:1,description:"Procedure annotations for soundness of proof rules."},l="Calculus Annotations",d={},a=[{value:"Usage",id:"usage",level:2},{value:"Soundness Overview of Proof Rules",id:"soundness-overview-of-proof-rules",level:2},{value:"What Is <em>Not</em> Checked By Caesar",id:"what-is-not-checked",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"calculus-annotations",children:"Calculus Annotations"})}),"\n","\n",(0,r.jsx)(n.p,{children:"Caesar supports annotations on procedures to specify a desired calculus to use.\nBy using these annotations, Caesar will help to check that only proof rules are used that are sound for that chosen calculus."}),"\n",(0,r.jsx)(n.p,{children:"Right now, Caesar supports:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"@wp"}),": The ",(0,r.jsx)(n.strong,{children:"weakest pre-expectation calculus"})," that operates on non-negative real numbers and infinity.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It corresponds to expected values of probabilistic programs where non-termination yields expected value zero."}),"\n",(0,r.jsxs)(n.li,{children:["Correspondingly, it uses ",(0,r.jsx)(n.em,{children:"least"})," fixpoint semantics for loops."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"@wlp"}),": The ",(0,r.jsxs)(n.strong,{children:["weakest ",(0,r.jsx)(n.em,{children:"liberal"})," pre-expectation calculus"]})," that operates on real numbers in the closed interval from zero to one.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It corresponds to expected values of probabilistic programs where non-termination yields expected value 1."}),"\n",(0,r.jsxs)(n.li,{children:["It uses ",(0,r.jsx)(n.em,{children:"greatest"})," fixpoint semantics for loops."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"@ert"}),": The ",(0,r.jsx)(n.strong,{children:"expected runtime calculus"})," for reasoning about expected runtimes or expected resource consumption of probabilistic programs.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The calculus is basically the same as the weakest pre-expectation calculus, with a lot of additonal ",(0,r.jsx)(n.code,{children:"+ 1"}),"s everywhere. In HeyVL, this corresponds to a bunch of ",(0,r.jsx)(n.code,{children:"tick 1"})," statements."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The formal details of these three calculi are presented very nicely in ",(0,r.jsx)(n.a,{href:"https://publications.rwth-aachen.de/record/755408/files/755408.pdf",children:"Benjamin Kaminski's PhD thesis"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsxs)(n.p,{children:["The calculus annotations do not automatically guarantee that your HeyVL file encodes your verification problems in a sound way.\nFor one, there are some conditions that are not (yet) checked by Caesar's implementation.\nSee the section ",(0,r.jsxs)(n.a,{href:"#what-is-not-checked",children:["What Is ",(0,r.jsx)(n.em,{children:"Not"})," Checked"]})," for more information."]})}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["Simply add the respective annotation to your ",(0,r.jsx)(n.code,{children:"proc"})," or ",(0,r.jsx)(n.code,{children:"coproc"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, the following ",(0,r.jsx)(n.code,{children:"proc"})," declaration will not compile because ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"induction"})," is not a sound proof rule to be used with ",(0,r.jsx)(n.code,{children:"wp"})," reasoning about lower bounds.\nA valid proof rule would be ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/omega-invariants",children:"\u03c9-invariants"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-heyvl",children:"@wp\nproc main() -> () {\n    var x: UInt\n    @invariant(x)\n    while 1 <= x {\n        x = x - 1\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.a,{href:"/docs/proof-rules/",children:"built-in proof rule"})," specifies their soundness theorem on their own documentation page (see the ",(0,r.jsx)(n.em,{children:'"Soundness"'})," sections)."]}),"\n",(0,r.jsx)(n.h2,{id:"soundness-overview-of-proof-rules",children:"Soundness Overview of Proof Rules"}),"\n",(0,r.jsxs)(n.p,{children:["So, what are the proof rules that can be used to reason about which calculus and about which direction?\nThe following table contains combinations of ",(0,r.jsx)(n.em,{children:"sound approximation"})," combinations, i.e. if the program with the proof rule verifies, then the original program with the true greatest/least fixpoint semantics satisfies the same specification as well."]}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Proof Rule"}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@wp"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@wlp"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@ert"})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./induction",children:"(k)-Induction"})}),(0,r.jsxs)("td",{children:["Overapproximation (",(0,r.jsx)("code",{children:"coproc"}),")"]}),(0,r.jsxs)("td",{children:["Underapproximation (",(0,r.jsx)("code",{children:"proc"}),")"]}),(0,r.jsxs)("td",{children:["Overapproximation (",(0,r.jsx)("code",{children:"coproc"}),")"]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./unrolling",children:"Loop Unrolling"})}),(0,r.jsxs)("td",{children:["Underapproximation (",(0,r.jsx)("code",{children:"proc"}),")"]}),(0,r.jsxs)("td",{children:["Overapproximation (",(0,r.jsx)("code",{children:"coproc"}),")"]}),(0,r.jsxs)("td",{children:["Underapproximation (",(0,r.jsx)("code",{children:"proc"}),")"]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./omega-invariants",children:"\u03c9-invariants"})}),(0,r.jsxs)("td",{children:["Underapproximation (",(0,r.jsx)("code",{children:"proc"}),")"]}),(0,r.jsxs)("td",{children:["Overapproximation (",(0,r.jsx)("code",{children:"coproc"}),")"]}),(0,r.jsxs)("td",{children:["Underapproximation (",(0,r.jsx)("code",{children:"proc"}),")"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The following proof rules implicitly assume that you do not approximate in your while loops, but encode ",(0,r.jsx)(n.em,{children:"exact"})," ",(0,r.jsx)(n.code,{children:"wp"}),"/",(0,r.jsx)(n.code,{children:"ert"})," semantics of your program.\nThis is because these proof rules implicitly do both lower and upper bounds checks on the loop body and thus the exact loop body semantics are required."]}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Proof Rule"}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@wp"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@wlp"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{children:"@ert"})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./ast",children:"Almost-Sure Termination Rule"})}),(0,r.jsxs)("td",{children:["Exact (",(0,r.jsx)("code",{children:"proc"}),")"]}),(0,r.jsx)("td",{children:"Not Applicable"}),(0,r.jsx)("td",{children:"Not Applicable"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./past",children:"Positive Almost-Sure Termination Rule"})}),(0,r.jsx)("td",{children:"Not Applicable"}),(0,r.jsx)("td",{children:"Not Applicable"}),(0,r.jsxs)("td",{children:["Exact (",(0,r.jsx)("code",{children:"coproc"}),")"]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.A,{to:"./ost",children:"Optional Stopping Theorem"})}),(0,r.jsxs)("td",{children:["Exact (",(0,r.jsx)("code",{children:"proc"}),")"]}),(0,r.jsx)("td",{children:"Not Applicable"}),(0,r.jsx)("td",{children:"Not Applicable"})]})]})]}),"\n",(0,r.jsxs)(n.h2,{id:"what-is-not-checked",children:["What Is ",(0,r.jsx)(n.em,{children:"Not"})," Checked By Caesar"]}),"\n",(0,r.jsxs)(n.p,{children:["HeyVL is designed as an intermediate verification language and so it allows some dangerous features on purpose.\nSee our ",(0,r.jsx)(n.a,{href:"/docs/publications#oopsla-23",children:"OOPSLA '23 paper"})," for more information.\nHowever, some items from the list below might also be disallowed in the future."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["You can easily introduce contradictions that lead to unsoundness.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["E.g. ",(0,r.jsx)(n.code,{children:"assume ?(false)"})," can be used in ",(0,r.jsx)(n.code,{children:"proc"}),"s to make everything verify trivially."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/heyvl/domains#unsoundness-from-axioms",children:"Unsoundness may come from axioms with contradictions"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"proc"}),"s may call ",(0,r.jsx)(n.code,{children:"coproc"}),"s and vice versa. However, this is almost never sound."]}),"\n",(0,r.jsx)(n.li,{children:"Right now, you can call procedures of different calculi from each other without a warning."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tick"})," statements may be used with ",(0,r.jsx)(n.code,{children:"@wp"})," and ",(0,r.jsx)(n.code,{children:"wlp"}),", and it is not checked that a ",(0,r.jsx)(n.code,{children:"tick"})," statement actually occurs in an ",(0,r.jsx)(n.code,{children:"@ert"})," procedure."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var o=s(6540);const r={},i=o.createContext(r);function t(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);