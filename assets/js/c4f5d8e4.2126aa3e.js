"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[2634],{2083:(e,s,i)=>{i.r(s),i.d(s,{default:()=>g});i(6540);function t(e){var s,i,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(s=0;s<e.length;s++)e[s]&&(i=t(e[s]))&&(n&&(n+=" "),n+=i);else for(s in e)e[s]&&(n&&(n+=" "),n+=s);return n}const n=function(){for(var e,s,i=0,n="";i<arguments.length;)(e=arguments[i++])&&(s=t(e))&&(n&&(n+=" "),n+=s);return n};var r=i(8774),a=i(4586),o=i(1330);const l={features:"features_t9lD",featureBox:"featureBox_LvN1",featureSvg:"featureSvg_GfXr",invertDark:"invertDark_jaEU"};var c=i(1028),d=i(4848);const h=[{title:"Expectation-Based Reasoning",image:"/img/expected-value.svg",alt:"E(X)",description:(0,d.jsxs)(d.Fragment,{children:["Our approach is based on ",(0,d.jsx)("i",{children:"weakest precondition-style reasoning"}),", generalized to probabilistic programs. We can reason about lower and upper bounds of expected values."]}),invertDark:!0},{title:"A Quantitative Intermediate Verification Language",image:"/img/heyvl.svg",alt:"HeyVL Logo",description:(0,d.jsxs)(d.Fragment,{children:["Caesar is built on our novel quantitative intermediate verification language ",(0,d.jsx)("i",{children:"HeyVL"}),". ",(0,d.jsx)("br",{}),(0,d.jsx)(r.A,{to:"/docs/publications#oopsla-23",children:"See our OOPSLA '23 paper!"})]}),invertDark:!0},{title:"A Collaborative Effort",image:"/img/logos.svg",alt:"i2 Logo",description:(0,d.jsxs)(d.Fragment,{children:["Caesar is an open-source project from ",(0,d.jsx)(r.A,{to:"https://moves.rwth-aachen.de/",children:"RWTH Aachen University (MOVES group)"}),", ",(0,d.jsx)(r.A,{to:"https://quave.cs.uni-saarland.de/",children:"Saarland University (QUAVE group)"}),", ",(0,d.jsx)(r.A,{to:"https://www.compute.dtu.dk/english/research/research-sections/software-systems-engineering",children:"Denmark Technical University (SSE section)"}),", and ",(0,d.jsx)(r.A,{to:"http://pplv.cs.ucl.ac.uk/welcome/",children:"University College London (PPLV group)"}),"."]}),invertDark:!1}];function p({title:e,image:s,alt:i,description:t,invertDark:r}){const a=r?`${l.featureSvg} ${l.invertDark}`:l.featureSvg;return(0,d.jsxs)("div",{className:n("col col--4",l.featureBox),children:[(0,d.jsx)("div",{className:"text--center",children:(0,d.jsx)("img",{src:s,className:a,alt:i})}),(0,d.jsxs)("div",{className:"text--center padding-horiz--md",children:[(0,d.jsx)("h3",{children:e}),(0,d.jsx)("p",{children:t})]})]})}function x(){return(0,d.jsx)("section",{className:l.features,children:(0,d.jsxs)("div",{className:"container",children:[(0,d.jsx)("div",{className:"row",children:h.map(((e,s)=>(0,d.jsx)(p,{...e},s)))}),(0,d.jsx)("hr",{style:{marginTop:"2.5em",marginBottom:"2.5em"}}),(0,d.jsx)("div",{className:"row",children:(0,d.jsxs)("div",{className:"col col--12",children:[(0,d.jsx)("h2",{children:"Features of HeyVL \u2014 Lossy List Traversal Example"}),(0,d.jsx)("p",{children:"Let's look at a program that traverses a list but has a chance of crashing during the traversal. We'll verify that the crash probability is at least 50% if the list has length 1."}),(0,d.jsxs)("p",{children:["We explain more of the details ",(0,d.jsx)(r.A,{to:"/docs/getting-started/",children:"as part of our getting started guide"}),"."]})]})}),(0,d.jsxs)("div",{className:"row",children:[(0,d.jsxs)("div",{className:"col col--6",children:[(0,d.jsxs)("h3",{children:["\ud83d\udca5 ",(0,d.jsx)("code",{children:"lossy_list"})," Procedure"]}),(0,d.jsxs)("p",{children:["This ",(0,d.jsx)(r.A,{to:"docs/heyvl/procs",children:"procedure"})," is the entry point. It has one output, the resulting list ",(0,d.jsx)("code",{children:"l"}),". In the body of ",(0,d.jsx)("code",{children:"lossy_list"}),", we traverse the list by repeatedly removing the first element using ",(0,d.jsx)("code",{children:"pop"}),". We model a 50% chance of crashing by a coin flip (",(0,d.jsx)("code",{children:"flip(0.5)"}),") leading to ",(0,d.jsx)("code",{children:"assert [false]"}),"."]}),(0,d.jsx)(c.A,{language:"heyvl",children:"proc lossy_list(init_l: List) -> (l: List)\n    pre [len(init_l) == 1] * 0.5  // quantitative specification!\n    post [true]\n{\n    l = init_l\n    @invariant(exp(0.5, len(l)))\n    while len(l) > 0 {\n        var prob_choice: Bool = flip(0.5) // coin flip\n        if prob_choice {\n            l = pop(l)     // next list element\n        } else {\n            assert [false] // crash\n        }\n    }\n}\n"})]}),(0,d.jsxs)("div",{className:"col col--6",children:[(0,d.jsx)("h3",{children:"\ud83d\udcd0 Reading The Spec"}),(0,d.jsxs)("p",{children:["Let's focus on the ",(0,d.jsx)("i",{children:"quantitative specification"})," of ",(0,d.jsx)("code",{children:"lossy_list"}),":"]}),(0,d.jsx)(c.A,{language:"heyvl",children:"pre [len(init_l) == 1] * 0.5\npost [true]"}),(0,d.jsxs)("p",{children:["The ",(0,d.jsx)("code",{children:"post"})," says that we are looking at the expected value of ",(0,d.jsx)("code",{children:"[true]"})," (i.e. 1) in the final states of the program. In other words, we are interested in the probability of running without an error."]}),(0,d.jsxs)("p",{children:["The ",(0,d.jsx)("code",{children:"pre"})," specifies a lower bound to the probability of a run without crashing (expected value of the post ",(0,d.jsx)("code",{children:"[true]"}),"). It says that if the length of the list is 1, then the lower bound is ",(0,d.jsx)("code",{children:"0.5"})," and otherwise ",(0,d.jsx)("code",{children:"0"}),"."]}),(0,d.jsxs)("p",{children:["To verify the spec, the ",(0,d.jsx)("code",{children:"while"})," loop has an ",(0,d.jsx)("code",{children:"@invariant"})," annotation with a ",(0,d.jsx)(r.A,{to:"/docs/proof-rules/induction",children:"probabilistic invariant"}),"."]})]})]}),(0,d.jsxs)("div",{className:"row",children:[(0,d.jsxs)("div",{className:"col col--6",children:[(0,d.jsx)("h3",{children:"\ud83c\udf0d Axiomatizing Exponentials and Lists"}),(0,d.jsxs)("p",{children:["Here is a strength of deductive verification: users can axomatize additional functions and data types that can be used for verification! We simply declare the ",(0,d.jsx)(r.A,{to:"/docs/heyvl/domains",children:"uninterpreted sort and functions"})," with just the necessary axioms in HeyVL."]}),(0,d.jsx)(c.A,{language:"heyvl",children:"domain Exponentials {\n    func exp(base: UReal, exponent: UInt): EUReal\n\n    axiom exp_base forall base: UReal.\n      exp(base, 0) == 1\n    axiom exp_step forall base: UReal, exponent: UInt.\n      exp(base, exponent + 1) == base * exp(base, exponent)\n}\n\ndomain List {\n    func len(l: List): UInt\n    func pop(l: List): List\n\n    axiom list_len forall l: List.\n      len(pop(l)) == len(l) - 1\n}"})]}),(0,d.jsxs)("div",{className:"col col--6",children:[(0,d.jsx)("h3",{children:"\ud83c\udfc3 Running Caesar"}),(0,d.jsxs)("p",{children:[(0,d.jsx)(r.A,{to:"https://github.com/moves-rwth/caesar/releases/latest",children:"Download"})," and extract the latest ",(0,d.jsx)("code",{children:"caesar"})," binary (or visit ",(0,d.jsx)(r.A,{to:"/docs/getting-started",children:(0,d.jsx)("i",{children:"Getting Started"})})," for alternative installation options)."]}),(0,d.jsxs)("p",{children:["The example from above is ",(0,d.jsx)(r.A,{to:"https://github.com/moves-rwth/caesar/blob/main/tests/domains/lossy_list.heyvl",children:"included in the Git repository"}),". After downloading and storing it in ",(0,d.jsx)("code",{children:"examples/lossy_list.heyvl"})," you can try Caesar on it:"]}),(0,d.jsx)(c.A,{language:"bash",children:"caesar verify examples/lossy_list.heyvl"}),(0,d.jsxs)("p",{children:["Caesar will print: ",(0,d.jsx)("code",{children:"examples/lossy_list.heyvl: Verified."})]})]})]})]})})}const u={heroBanner:"heroBanner_qdFl",heroBannerRow:"heroBannerRow_F26w",heroTitle:"heroTitle_qg2I",heroLogo:"heroLogo_U6bI",quickButtons:"quickButtons_fNHp",heroImageWrapper:"heroImageWrapper_Vsqa"};function m(){const{siteConfig:e}=(0,a.A)();return(0,d.jsx)("header",{className:n("hero hero--dark",u.heroBanner),children:(0,d.jsx)("div",{className:"container",children:(0,d.jsxs)("div",{className:`row ${u.heroBannerRow}`,children:[(0,d.jsxs)("div",{className:"col col--7",children:[(0,d.jsxs)("h1",{className:n("hero__title",u.heroTitle),children:[(0,d.jsx)("img",{src:"/img/laurel.svg",className:u.heroLogo,alt:""}),(0,d.jsx)("span",{children:e.title}),(0,d.jsx)("img",{src:"/img/laurel.svg",className:u.heroLogo,style:{transform:"scale(-1, 1)"},alt:""})]}),(0,d.jsxs)("p",{className:"hero__subtitle",children:[(0,d.jsx)("span",{style:{display:"inline-block"},children:"A Deductive Verifier\xa0"}),(0,d.jsx)("span",{style:{display:"inline-block"},children:"for Probabilistic Programs"})]}),(0,d.jsxs)("div",{className:u.quickButtons,children:[(0,d.jsx)(r.A,{className:"button button--primary",to:"/docs/getting-started",children:"Get Started \u2192"}),(0,d.jsx)(r.A,{className:"button button--primary",to:"https://marketplace.visualstudio.com/items?itemName=rwth-moves.caesar",children:"VSCode Extension"}),(0,d.jsx)(r.A,{className:"button button--primary",to:"/docs/",children:"Docs"})]})]}),(0,d.jsx)("div",{className:`col col--5 ${u.heroImageWrapper}`,children:(0,d.jsx)(r.A,{to:"/docs/",className:"margin--md shadow--md",children:(0,d.jsx)("img",{src:"img/architecture-oopsla23.svg",alt:"Architecture diagram for Caesar"})})})]})})})}function g(){const{siteConfig:e}=(0,a.A)();return(0,d.jsxs)(o.A,{title:"Caesar Verification Infrastructure",description:`${e.tagline}`,children:[(0,d.jsx)(m,{}),(0,d.jsx)("main",{children:(0,d.jsx)(x,{})})]})}}}]);