"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[6835],{560:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"heyvl/statements","title":"Statements","description":"Statements are executed sequentially and may have side-effects.","source":"@site/docs/heyvl/statements.md","sourceDirName":"heyvl","slug":"/heyvl/statements","permalink":"/docs/heyvl/statements","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/statements.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"Statements are executed sequentially and may have side-effects.","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Procedures","permalink":"/docs/heyvl/procs"},"next":{"title":"Expressions","permalink":"/docs/heyvl/expressions"}}');var a=s(4848),i=s(8453);const r={description:"Statements are executed sequentially and may have side-effects.",sidebar_position:2},o="Statements",c={},l=[{value:"Semantics: The Meaning of HeyVL Programs",id:"semantics",level:2},{value:"Concrete Statements",id:"concrete-statements",level:2},{value:"Blocks",id:"blocks",level:3},{value:"Variable Declarations",id:"variable-declarations",level:3},{value:"Assignments and Procedure Calls",id:"assignments",level:3},{value:"Boolean Choices",id:"boolean-choices",level:3},{value:"While Loops",id:"while-loops",level:3},{value:"Verification Statements",id:"verification-statements",level:2},{value:"Havoc",id:"havoc",level:3},{value:"Assert and Assume",id:"assert-and-assume",level:3},{value:"Reward",id:"reward",level:3},{value:"Nondeterministic Choices",id:"nondeterministic-choices",level:3},{value:"Deprecated Statements",id:"deprecated-statements",level:2},{value:"Compare",id:"compare",level:3},{value:"Negations",id:"negations",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"statements",children:"Statements"})}),"\n",(0,a.jsxs)(n.p,{children:["Statements in HeyVL are instructions that are interpreted sequentially and that have side-effects.\nThey are used inside the body of ",(0,a.jsx)(n.a,{href:"/docs/heyvl/procs",children:"procedures"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["We can categorize HeyVL's statements into either ",(0,a.jsx)(n.em,{children:"concrete"})," or ",(0,a.jsx)(n.em,{children:"verification"})," statements.\nWe have ",(0,a.jsx)(n.a,{href:"#concrete-statements",children:"concrete statements"})," and ",(0,a.jsx)(n.a,{href:"#verification-statements",children:"verification statements"}),".\nConcrete statements include ",(0,a.jsx)(n.a,{href:"#assignments",children:"assignments"}),", ",(0,a.jsx)(n.a,{href:"#boolean-choices",children:"Boolean choices"}),", and ",(0,a.jsx)(n.a,{href:"#while-loops",children:"while loops"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of ",(0,a.jsx)(n.em,{children:"verification statements"})," is to encode either ",(0,a.jsx)(n.em,{children:"proof obligations"})," and ",(0,a.jsx)(n.em,{children:"proof assumptions"}),".\nFor example, ",(0,a.jsx)(n.a,{href:"#assert-and-assume",children:"assert and assume statements"})," are used to do this.\nWhen you are verifying programs, you ideally do not use these verification statements directly but instead use Caesar's built-in set of ",(0,a.jsx)(n.a,{href:"../proof-rules/",children:"proof rules"}),".\nThey internally use verification statements, but Caesar's proof rules guarantee correct usage so that the proofs are sound."]}),"\n",(0,a.jsx)(n.p,{children:"Below is an overview of HeyVL's statements with links to the respective documentation sections:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:(0,a.jsx)(n.a,{href:"#concrete-statements",children:"Concrete Statements"})}),(0,a.jsx)(n.th,{children:(0,a.jsx)(n.a,{href:"#verification-statements",children:"Verification Statements"})})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#blocks",children:"Blocks"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#assert-and-assume",children:"Assert and Assume"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#variable-declarations",children:"Variable Declarations"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#havoc",children:"Havoc"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#assignments",children:"Assignments and Procedure Calls"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#reward",children:"Reward"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#boolean-choices",children:"Boolean Choices"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#nondeterministic-choices",children:"Nondeterministic Choices"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"#while-loops",children:"While Loops"})}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["There are also some ",(0,a.jsx)(n.a,{href:"#deprecated-statements",children:"deprecated verification statements"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"semantics",children:"Semantics: The Meaning of HeyVL Programs"}),"\n",(0,a.jsxs)(n.p,{children:["Since HeyVL is an intermediate verification language, not all statements allow an operational interpretation of their effects.\nAll HeyVL statements should be understood through their (quantitative) verification condition semantics.\nThese are defined in reverse order, starting from an initial verification condition and proceeding from the last statement backwards to the front.\nWe describe the ",(0,a.jsx)(n.em,{children:"formal semantics of HeyVL statements"})," ",(0,a.jsx)(n.a,{href:"https://arxiv.org/pdf/2309.07781.pdf#page=10",children:"in our paper on Caesar (cf. Section 3)"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"concrete-statements",children:"Concrete Statements"}),"\n",(0,a.jsx)(n.h3,{id:"blocks",children:"Blocks"}),"\n",(0,a.jsxs)(n.p,{children:["A block is a sequence of statements enclosed by curly braces.\nStatements ",(0,a.jsx)(n.em,{children:"may"})," be separated by semicolons, but those can be omitted.\nEach block creates a ",(0,a.jsx)(n.em,{children:"local scope"})," into which variables are declared.\nBlocks can be nested.\nFor example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"x = 1\n{\n    var y: UInt\n}\ny = 1 // y is not declared in this scope\n"})}),"\n",(0,a.jsx)(n.h3,{id:"variable-declarations",children:"Variable Declarations"}),"\n",(0,a.jsxs)(n.p,{children:["A variable declaration creates a new local variable of type ",(0,a.jsx)(n.code,{children:"Type"})," in the current scope:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"var name: Type\n"})}),"\n",(0,a.jsxs)(n.p,{children:["See the ",(0,a.jsx)(n.a,{href:"../stdlib/",children:"standard library"})," for Caesar's built-in types and ",(0,a.jsx)(n.a,{href:"/docs/heyvl/domains",children:"domains"})," for user-defined types."]}),"\n",(0,a.jsx)(n.p,{children:"A variable declaration can be combined with an assignment to initialize the variable:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"var forty_two: UInt = 42\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If a variable is not initialized, the program will be verified ",(0,a.jsx)(n.em,{children:"for all"})," possible values of that variable."]}),"\n",(0,a.jsx)(n.h3,{id:"assignments",children:"Assignments and Procedure Calls"}),"\n",(0,a.jsx)(n.p,{children:"An assignment evaluates the expression on the right-hand side in the current state and assigns the result to the variable on the left-hand side.\nFor example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"x = 39 + y\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The right-hand side must evaluate to a value of a type that can be matches the type of ",(0,a.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The right-hand side of the assignment can be a procedure call.\nSee the ",(0,a.jsx)(n.a,{href:"/docs/heyvl/procs#calling-procedures",children:"reference on procedure calls"})," for more information.",(0,a.jsx)(n.sup,{children:(0,a.jsx)(n.a,{href:"#user-content-fn-calls-concrete",id:"user-content-fnref-calls-concrete","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,a.jsxs)(n.p,{children:["The left-hand side of an assignment may be a list of variables to unpack a tuple.\nFor example, imagine a procedure ",(0,a.jsx)(n.code,{children:"two_numbers"})," whose return type is ",(0,a.jsx)(n.code,{children:"(x: UInt, y: UInt)"}),".\nThe following statement assigns the result of a call to ",(0,a.jsx)(n.code,{children:"two_numbers"})," to ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"x, y = two_numbers()\n"})}),"\n",(0,a.jsx)(n.p,{children:"If the procedure does not have any return values, the call may be written without the equals sign and the left-hand side, i.e. simply:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"fn(arg1, arg2)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"boolean-choices",children:"Boolean Choices"}),"\n",(0,a.jsx)(n.p,{children:"HeyVL supports a binary choice depending on the value of a Boolean expression:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"if x + 1 == 2 {\n    ...\n} else {\n    ...\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"while-loops",children:"While Loops"}),"\n",(0,a.jsx)(n.p,{children:"HeyVL supports while loops that run a block of code while a condition evaluates to true."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"var cont: Bool = true\n@invariant(...)\nwhile cont {\n    cont = flip(0.5)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For verification, ",(0,a.jsxs)(n.strong,{children:["while loops need to have ",(0,a.jsx)(n.a,{href:"../proof-rules/",children:"proof rule annotations"})]})," such as the ",(0,a.jsxs)(n.a,{href:"/docs/proof-rules/induction",children:[(0,a.jsx)(n.code,{children:"@invariant(...)"})," annotation"]})," in the example.\nIf a while loop does not have a proof rule annotation, Caesar cannot verify the program and will show an error."]}),"\n",(0,a.jsxs)(n.p,{children:["The proof rule annotations also implicitly specify whether the loop has least or greatest fixpoint semantics.\nThis choice can be made explicit with the ",(0,a.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"calculus annotations"})," on procedures, which we recommend you use."]}),"\n",(0,a.jsxs)(n.p,{children:["With the ",(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.a,{href:"/docs/model-checking",children:"model checking translation"}),", proof rule annotations are not necessary"]}),".\nIt allows usage of a ",(0,a.jsx)(n.em,{children:"probabilistic model checker"})," such as ",(0,a.jsx)(n.a,{href:"https://www.stormchecker.org/",children:"Storm"})," for a subset of HeyVL programs.\nThis can be helpful to e.g. get an initial estimation of expected values."]}),"\n",(0,a.jsx)(n.h2,{id:"verification-statements",children:"Verification Statements"}),"\n",(0,a.jsx)(n.h3,{id:"havoc",children:"Havoc"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"havoc"}),' statement can be used to "forget" previous values of variables in the following code.\nIt also comes in a ',(0,a.jsx)(n.code,{children:"co"})," variant."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"havoc x, y, z\ncohavoc a, b, c\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The verification condition semantics of ",(0,a.jsx)(n.code,{children:"havoc"})," and ",(0,a.jsx)(n.code,{children:"cohavoc"})," create an infimum respectively supremum over the specified variables."]}),"\n",(0,a.jsx)(n.h3,{id:"assert-and-assume",children:"Assert and Assume"}),"\n",(0,a.jsxs)(n.p,{children:["These statements generate binary operators in the verification condition semantics.\nAll three statements also come in ",(0,a.jsx)(n.code,{children:"co"})," variants.\n",(0,a.jsx)(n.code,{children:"(co)assert"})," generates an infimum respectively supremum.\n",(0,a.jsx)(n.code,{children:"(co)assume"})," generates an implication respectively co-implication."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"assert 1 + x\nassume 0\n"})}),"\n",(0,a.jsx)(n.h3,{id:"reward",children:"Reward"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"reward"})," statement accepts an expression and adds it to the current verification condition.\nFor example,"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"reward 2 * x\n"})}),"\n",(0,a.jsxs)(n.p,{children:["has the following semantics: ",(0,a.jsx)(n.code,{children:"vc[reward 2 * x](f) = f + (2 * x)"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"tick"})," is another name that Caesar accepts for ",(0,a.jsx)(n.code,{children:"reward"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"nondeterministic-choices",children:"Nondeterministic Choices"}),"\n",(0,a.jsxs)(n.p,{children:['HeyVL supports two kinds of binary nondeterministic choices: The "demonic" one (',(0,a.jsx)(n.code,{children:"if \u2293"}),') and the "angelic" one (',(0,a.jsx)(n.code,{children:"if \u2294"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-heyvl",children:"if \u2293 {\n    ...\n} else {\n    ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can also use Latex-style syntax instead of Unicode.\nCaesar supports ",(0,a.jsx)(n.code,{children:"\\cap"})," and ",(0,a.jsx)(n.code,{children:"\\cup"})," instead of ",(0,a.jsx)(n.code,{children:"\u2293"})," and ",(0,a.jsx)(n.code,{children:"\u2294"}),", respectively.\n(We're looking for better syntax for these statements. If you have an idea, ",(0,a.jsx)(n.a,{href:"https://github.com/moves-rwth/caesar/discussions",children:"please start a discussion"}),".)"]}),"\n",(0,a.jsx)(n.h2,{id:"deprecated-statements",children:"Deprecated Statements"}),"\n",(0,a.jsxs)(n.p,{children:["Caesar supports some HeyVL statements that are not part of the HeyVL language ",(0,a.jsx)(n.a,{href:"/docs/publications#oopsla-23",children:"published in our OOPSLA '23 paper"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsx)(n.p,{children:"These statements were used for previous iterations of HeyVL, but may be removed from Caesar at any time."})}),"\n",(0,a.jsx)(n.h3,{id:"compare",children:"Compare"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"compare f"})," statement corresponds to an abbreviation of ",(0,a.jsx)(n.code,{children:"validate; assume f"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The dual ",(0,a.jsx)(n.code,{children:"cocompare f"})," statement corresponds to an abbreviation of ",(0,a.jsx)(n.code,{children:"covalidate; coassume f"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"negations",children:"Negations"}),"\n",(0,a.jsxs)(n.p,{children:["We have a ",(0,a.jsx)(n.code,{children:"negate"})," and an ",(0,a.jsx)(n.code,{children:"conegate"})," statement, whose semantics correspond to HeyLo's negations."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"validate"})," statement corresponds to ",(0,a.jsx)(n.code,{children:"conegate; conegate"})," and ",(0,a.jsx)(n.code,{children:"covalidate"})," corresponds to ",(0,a.jsx)(n.code,{children:"negate; negate"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"It is recommended that you avoid negations for the reasons detailed in the warning below."}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsxs)(n.p,{children:["Negation statements in HeyVL break ",(0,a.jsx)(n.em,{children:"monotonicity"}),", an important property of HeyVL semantics that is required for sound ",(0,a.jsx)(n.a,{href:"/docs/heyvl/procs#calling-procedures",children:"(co)procedure calls"}),".\nIf negations are used in such a way that monotonicity is broken, then (co)procedure calls are unsound.\nRefer to our ",(0,a.jsx)(n.a,{href:"/docs/publications#oopsla-23",children:"OOPSLA '23 paper"})," for details on monotonicity and soundness of (co)procedure calls."]})}),"\n","\n",(0,a.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,a.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{id:"user-content-fn-calls-concrete",children:["\n",(0,a.jsxs)(n.p,{children:["Note that a procedure does not necessarily need to have a body.\nCaesar will verify calls only based on their specification.\nIn those cases, a procedure call is thus not concrete. ",(0,a.jsx)(n.a,{href:"#user-content-fnref-calls-concrete","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);