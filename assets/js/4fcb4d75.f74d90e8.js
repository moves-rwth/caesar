"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[2762],{941:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"caesar/debugging","title":"Debugging","description":"Follow this guide if you are debugging verification with Caesar.","source":"@site/docs/caesar/debugging.md","sourceDirName":"caesar","slug":"/caesar/debugging","permalink":"/docs/caesar/debugging","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/caesar/debugging.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"The Caesar Tool","permalink":"/docs/caesar/"},"next":{"title":"VSCode Extension & LSP Support","permalink":"/docs/caesar/vscode-and-lsp"}}');var s=n(4848),t=n(8453);const o={sidebar_position:1},a="Debugging",c={},l=[{value:"SMT Theories and Incompleteness",id:"incompleteness",level:2},{value:"Z3 Probes",id:"z3-probes",level:3},{value:"Further Reading",id:"further-reading",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"debugging",children:"Debugging"})}),"\n",(0,s.jsx)(i.p,{children:"Follow this guide if you are debugging verification with Caesar."}),"\n",(0,s.jsx)(i.h2,{id:"incompleteness",children:"SMT Theories and Incompleteness"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.a,{href:"/docs/heyvl/expressions",children:"Expressions"})," are the main reason for ",(0,s.jsx)(i.em,{children:"incompleteness"})," of Caesar, i.e. instances Caesar is unable to decide whether a given HeyVL program verifies or not.\nCaesar's incompleteness comes from incompleteness of the underlying SMT solver which is used to prove or disprove verification."]}),"\n",(0,s.jsxs)(i.p,{children:["At the moment, Caesar's translation of HeyVL verification problems is rather direct: most expressions are translated as one would intuitively expect.\nIf operators have a direct correspondence in ",(0,s.jsx)(i.a,{href:"https://smt-lib.org/",children:"SMT-LIB"}),", then we translate directly to those.\nOtherwise, usually only additional simple case distinctions are introduced.\nWe have some more explanations in ",(0,s.jsx)(i.a,{href:"https://arxiv.org/pdf/2309.07781#page=23",children:"Section 5 of our paper on HeyVL"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["As a consequence, it is usually pretty simple to predict which ",(0,s.jsx)(i.a,{href:"https://smt-lib.org/theories.shtml",children:"SMT-LIB theories"})," will be used for the SMT query done by Caesar.\n",(0,s.jsx)(i.a,{href:"#z3-probes",children:"Caesar supports Z3 probes"})," to help you check in which theory your problem falls.\nAlso refer to the ",(0,s.jsx)(i.a,{href:"https://microsoft.github.io/z3guide/docs/theories/Arithmetic/",children:"Z3 documentation on arithmetic theories"}),", since a lot of Caesar's reasoning will need arithmetic."]}),"\n",(0,s.jsx)(i.p,{children:"Here are some rules of thumb for (in-)completeness:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Linear integer and real arithmetic (QF_LRA, QF_LIRA) is decidable."}),"\n",(0,s.jsx)(i.li,{children:"Nonlinear integer arithmetic (QF_NIA) is undecidable."}),"\n",(0,s.jsx)(i.li,{children:"Nonlinear real arithmetic (QF_NRA) is decidable for algebraic reals."}),"\n",(0,s.jsxs)(i.li,{children:["Quantifiers usually introduce undecidability, although there are ",(0,s.jsx)(i.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Quantifiers#model-based-quantifier-instantiation",children:"a bunch of strategies and fragments in Z3 that allow decidability"}),".","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["In particular, restrictive ",(0,s.jsx)(i.a,{href:"/docs/heyvl/expressions#triggers",children:"quantifier triggers"})," can help e-matching prove many instances."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["HeyVL's ",(0,s.jsx)(i.a,{href:"/docs/heyvl/expressions#quantifiers",children:"quantitative quantifiers"})," (",(0,s.jsx)(i.code,{children:"inf"})," and ",(0,s.jsx)(i.code,{children:"sup"}),") currently have a very naive default encoding that is problematic for Z3.  If the quantitative quantifiers cannot be eliminated by Caesar's quantifier elimination (QE) procedure, then they are often a cause of nontermination of Caesar.","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Quantitative quantifiers also come from the semantics of ",(0,s.jsxs)(i.a,{href:"/docs/heyvl/statements#havoc",children:[(0,s.jsx)(i.code,{children:"havoc"})," and ",(0,s.jsx)(i.code,{children:"cohavoc"})]}),". However, for e.g. the ",(0,s.jsx)(i.a,{href:"/docs/proof-rules/induction",children:"induction-based proof rules"}),", the HeyVL encodings fall into a fragment where Caesar's QE applies and the generated quantifiers are eliminated."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["In practice, the SMT solver can often ",(0,s.jsx)(i.em,{children:"prove"})," correctness, but it often has problems with ",(0,s.jsx)(i.em,{children:"refutations"})," (i.e. providing counter-examples)."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"z3-probes",children:"Z3 Probes"}),"\n",(0,s.jsxs)(i.p,{children:["Caesar supports the use of ",(0,s.jsxs)(i.a,{href:"https://microsoft.github.io/z3guide/docs/strategies/probes/",children:["Z3's ",(0,s.jsx)(i.em,{children:"probes"})]})," to quickly help you determine performance-relevant properties about the SMT query, such as the presence of quantifiers or the theoretical complexity of the problem."]}),"\n",(0,s.jsxs)(i.p,{children:["Run Caesar with the ",(0,s.jsx)(i.code,{children:"--probe"})," flag to enable probes.\nCaesar will print an output of the following form to standard error:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"Probe results for test.heyvl::test:\nHas quantifiers: false\nDetected theories: NIRA\n - complexity: Undecidable\n - rejected theories: LRA, LIA, LIRA, NRA, NIA\nNumber of arithmetic constants: 1\nNumber of Boolean constants: 4\nNumber of bit-vector constants: 0\nNumber of constants: 1\nNumber of expressions: 71\n"})}),"\n",(0,s.jsx)(i.p,{children:'The tool also tries to compute the complexity class of the problem to help you determine whether a problem is "easy".'}),"\n",(0,s.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://dafny.org/dafny/DafnyRef/DafnyRef.html#sec-verification",children:"Dafny's guidelines for verification"})," can be helpful.\nMany of the ideas translate pretty much directly to Caesar."]}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var r=n(6540);const s={},t=r.createContext(s);function o(e){const i=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:i},e.children)}}}]);