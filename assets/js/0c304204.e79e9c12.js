"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[657],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(n),u=i,f=p["".concat(l,".").concat(u)]||p[u]||d[u]||r;return n?a.createElement(f,s(s({ref:t},m),{},{components:n})):a.createElement(f,s({ref:t},m))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3901:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(7294),i=n(3743);const r={tableOfContentsInline:"tableOfContentsInline_prmo"};function s(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:s}=e;return a.createElement("div",{className:r.tableOfContentsInline},a.createElement(i.Z,{toc:t,minHeadingLevel:n,maxHeadingLevel:s,className:"table-of-contents",linkClassName:null}))}},3743:(e,t,n)=>{n.d(t,{Z:()=>f});var a=n(7462),i=n(7294),r=n(6668);function s(e){const t=e.map((e=>({...e,parentIndex:-1,children:[]}))),n=Array(7).fill(-1);t.forEach(((e,t)=>{const a=n.slice(2,e.level);e.parentIndex=Math.max(...a),n[e.level]=t}));const a=[];return t.forEach((e=>{const{parentIndex:n,...i}=e;n>=0?t[n].children.push(i):a.push(i)})),a}function o(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return t.flatMap((e=>{const t=o({toc:e.children,minHeadingLevel:n,maxHeadingLevel:a});return function(e){return e.level>=n&&e.level<=a}(e)?[{...e,children:t}]:t}))}function l(e){const t=e.getBoundingClientRect();return t.top===t.bottom?l(e.parentNode):t}function c(e,t){let{anchorTopOffset:n}=t;const a=e.find((e=>l(e).top>=n));if(a){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(l(a))?a:e[e.indexOf(a)-1]??null}return e[e.length-1]??null}function m(){const e=(0,i.useRef)(0),{navbar:{hideOnScroll:t}}=(0,r.L)();return(0,i.useEffect)((()=>{e.current=t?0:document.querySelector(".navbar").clientHeight}),[t]),e}function p(e){const t=(0,i.useRef)(void 0),n=m();(0,i.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:a,linkActiveClassName:i,minHeadingLevel:r,maxHeadingLevel:s}=e;function o(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(a),o=function(e){let{minHeadingLevel:t,maxHeadingLevel:n}=e;const a=[];for(let i=t;i<=n;i+=1)a.push(`h${i}.anchor`);return Array.from(document.querySelectorAll(a.join()))}({minHeadingLevel:r,maxHeadingLevel:s}),l=c(o,{anchorTopOffset:n.current}),m=e.find((e=>l&&l.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,n){n?(t.current&&t.current!==e&&t.current.classList.remove(i),e.classList.add(i),t.current=e):e.classList.remove(i)}(e,e===m)}))}return document.addEventListener("scroll",o),document.addEventListener("resize",o),o(),()=>{document.removeEventListener("scroll",o),document.removeEventListener("resize",o)}}),[e,n])}function d(e){let{toc:t,className:n,linkClassName:a,isChild:r}=e;return t.length?i.createElement("ul",{className:r?void 0:n},t.map((e=>i.createElement("li",{key:e.id},i.createElement("a",{href:`#${e.id}`,className:a??void 0,dangerouslySetInnerHTML:{__html:e.value}}),i.createElement(d,{isChild:!0,toc:e.children,className:n,linkClassName:a}))))):null}const u=i.memo(d);function f(e){let{toc:t,className:n="table-of-contents table-of-contents__left-border",linkClassName:l="table-of-contents__link",linkActiveClassName:c,minHeadingLevel:m,maxHeadingLevel:d,...f}=e;const h=(0,r.L)(),g=m??h.tableOfContents.minHeadingLevel,k=d??h.tableOfContents.maxHeadingLevel,v=function(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return(0,i.useMemo)((()=>o({toc:s(t),minHeadingLevel:n,maxHeadingLevel:a})),[t,n,a])}({toc:t,minHeadingLevel:g,maxHeadingLevel:k});return p((0,i.useMemo)((()=>{if(l&&c)return{linkClassName:l,linkActiveClassName:c,minHeadingLevel:g,maxHeadingLevel:k}}),[l,c,g,k])),i.createElement(u,(0,a.Z)({toc:v,className:n,linkClassName:l},f))}},6220:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var a=n(7462),i=n(7294),r=n(3905),s=n(3901);const o={sidebar_position:1,description:"Caesar supports program slicing on the HeyVL intermediate verification language."},l="Program Slicing",c={unversionedId:"caesar/slicing",id:"caesar/slicing",title:"Program Slicing",description:"Caesar supports program slicing on the HeyVL intermediate verification language.",source:"@site/docs/caesar/slicing.md",sourceDirName:"caesar",slug:"/caesar/slicing",permalink:"/docs/caesar/slicing",draft:!1,editUrl:"https://github.com/moves-rwth/caesar/tree/main/website/docs/caesar/slicing.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Caesar supports program slicing on the HeyVL intermediate verification language."},sidebar:"docsSidebar",previous:{title:"The Caesar Tool",permalink:"/docs/caesar/"},next:{title:"Optimizations & Alternative Implementations",permalink:"/docs/caesar/optimizations"}},m={},p=[{value:"Overview",id:"overview",level:2},{value:"Slicing for Errors",id:"slicing-for-errors",level:2},{value:"Assertion Slicing",id:"assertion-slicing",level:3},{value:"General Slicing for Errors",id:"general-slicing-for-errors",level:3},{value:"Slicing for Correctness",id:"slicing-for-correctness",level:2},{value:"Assumption Slicing",id:"assumption-slicing",level:3},{value:"General Slicing for Correctness",id:"general-slicing-for-correctness",level:3},{value:"Slicing Annotations",id:"slicing-annotations",level:2},{value:"Slicing Message Annotations",id:"slicing-message-annotations",level:3},{value:"Slicing Selections",id:"slicing-selections",level:3},{value:"A Theory of Slicing for HeyVL",id:"a-theory-of-slicing-for-heyvl",level:2},{value:"Slice Effects",id:"slice-effects",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Program Transformation",id:"program-transformation",level:3},{value:"Solving for Minimal Slices",id:"solving-for-minimal-slices",level:3}],d={toc:p},u="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"program-slicing"},"Program Slicing"),(0,r.kt)("p",null,"Caesar supports ",(0,r.kt)("em",{parentName:"p"},"program slicing"),' on the HeyVL intermediate verification language.\nIt is the basis for Caesar\'s localized error reporting (e.g. "this loop invariant may not be inductive"), but we support more generalized slicing criteria as well.'),(0,r.kt)("p",null,"Caesar has support for ",(0,r.kt)("a",{parentName:"p",href:"#slicing-for-errors"},(0,r.kt)("em",{parentName:"a"},"slicing for errors")),", which aims at a sliced program that fails with a counter-example.\n",(0,r.kt)("a",{parentName:"p",href:"#assertion-slicing"},(0,r.kt)("em",{parentName:"a"},"Assertion slicing"))," with its purpose of localizing error messages falls is a kind of slicing for errors.\n",(0,r.kt)("a",{parentName:"p",href:"#slicing-for-correctness"},(0,r.kt)("em",{parentName:"a"},"Slicing for correctness"))," is aimed at finding a sliced program that verifies.\n",(0,r.kt)("a",{parentName:"p",href:"#assumption-slicing"},(0,r.kt)("em",{parentName:"a"},"Assumption slicing"))," is one kind of slicing for correctness."),(0,r.kt)("p",null,"Fun fact: Caesar's slicing feature was developed with the project name ",(0,r.kt)("em",{parentName:"p"},"Brutus")," ","\u2014"," alluding to Caesar's adopted son, who also famously participated in a very different way of slicing..."),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In this document:")),(0,r.kt)(s.Z,{toc:p,mdxType:"TOCInline"}),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#assertion-slicing"},(0,r.kt)("em",{parentName:"a"},"Assertion slicing"))," is enabled by default on every verification query to help interpret a counterexample.\nIt does this by finding a minimal set of ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),"-like statements that must be in the code to obtain a verification error.\nCaesar's built-in ",(0,r.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules")," have annotations that provide interpretations to every ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),".\nFor example, there is an assertion in the encoding of ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/induction"},"induction")," whose presence in a minimal counterexample slice means that the invariant might not be inductive."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#assumption-slicing"},(0,r.kt)("em",{parentName:"a"},"Assumption slicing"))," must be enabled with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--slice-verify")," command-line flag.\nIt can be used to find a minimal set of ",(0,r.kt)("inlineCode",{parentName:"p"},"assume"),"-like statements with which the program verifies.\nThis may help optimizing or understanding a HeyVL proof.\nFor example, there's an ",(0,r.kt)("inlineCode",{parentName:"p"},"assume")," in the induction encoding inside a verifying HeyVL program.\nThe removal of that ",(0,r.kt)("inlineCode",{parentName:"p"},"assume")," indicates that a ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loop could also be just a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," statement for verification.\nThis could indicate a problem in the specification to be proved if the user knows a ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," statement should be necessary."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#slicing-for-errors"},(0,r.kt)("em",{parentName:"a"},"Slicing for errors"))," generalizes assertion slicing to statements that are not necessarily ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),"-like and ",(0,r.kt)("a",{parentName:"p",href:"#general-slicing-for-correctness"},(0,r.kt)("em",{parentName:"a"},"slicing for correctness"))," does the same for statements that are not necessarily ",(0,r.kt)("inlineCode",{parentName:"p"},"assume"),"-like.\nWe discuss these generalized applications in the respective sections ",(0,r.kt)("a",{parentName:"p",href:"#general-slicing-for-errors"},"General Slicing for Errors")," and ",(0,r.kt)("a",{parentName:"p",href:"#general-slicing-for-correctness"},"General Slicing for Correctness"),"."),(0,r.kt)("p",null,"On a very high level, Caesar's program slicing works by trying all different combinations of removing all candidate statements for the slice.\nOur ",(0,r.kt)("a",{parentName:"p",href:"#a-theory-of-slicing-for-heyvl"},"theory of slicing")," for HeyVL formalizes the ideas of ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"assert"),"-like")," and ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"assume"),"-like")," via the ",(0,r.kt)("em",{parentName:"p"},"discordant")," and ",(0,r.kt)("em",{parentName:"p"},"concordant")," definitions and specifies soundness of slicing using these terms.\nCaesar's ",(0,r.kt)("a",{parentName:"p",href:"#slicing-annotations"},"annotations for slicing")," can be used to add slicing information to statements such as error messages for assertions.\nIn the last section of this document, we describe ",(0,r.kt)("a",{parentName:"p",href:"#implementation-details"},"implementation details")," of the slicing algorithm in Caesar."),(0,r.kt)("p",null,"Interestingly, Caesar's slicing is in essence not very different from slicing-like approaches in classical deductive verifiers.\nWe just generalized the ideas to the ",(0,r.kt)("em",{parentName:"p"},"quantitative")," setting of our intermediate verification language HeyVL, but the ideas are equally applicable to the ",(0,r.kt)("em",{parentName:"p"},"qualitative")," setting."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Since our approach generalizes the qualitative setting and to simplify the presentation here, we will mostly give ",(0,r.kt)("em",{parentName:"p"},"qualitative")," examples in the following to illustrate the ideas.\nBut keep in mind that everything also works for quantitative verification tasks in the same way.")),(0,r.kt)("p",null,"To our knowledge, Caesar's implementation of slicing is the first one that combines both slicing for errors, for correctness, on an IVL, in the quantitative setting."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Our slicing approach is still a work-in-progress which we hope to present in an upcoming academic publication.")),(0,r.kt)("p",null,"The following flowchart illustrates Caesar's slicing algorithm."),(0,r.kt)("mermaid",{value:"flowchart TD\n    start[/Program/]\n    query1{Verifies?}\n    start --\x3e query1\n\n    verifies1(Verifies)\n    cex1(Counter-Example)\n    query1 --\x3e cex1\n    query1 --\x3e verifies1\n\n    %% unknown1(Unknown)\n    %% query1 --\x3e unknown1\n\n    cex1 --\x3e slicing_errors\n    subgraph slicing_errors[Slicing for Errors]\n        cex1_slice[[Slice statements]]\n        cex1_slice --\x3e cex1_slice\n        cex1_done[/Minimal cex'ing slice/]\n        cex1_slice --\x3e cex1_done\n        cex1_conclusion{Selection <br>assert-like?}\n        cex1_done --\x3e cex1_conclusion\n        cex1_discordant[/Cex also valid <br>for original program/]\n        cex1_unknown[/New cex'ing program/]\n        cex1_conclusion --Yes --\x3e cex1_discordant\n        cex1_conclusion --No --\x3e cex1_unknown\n    end\n\n    verifies1 -- --slice-verify --\x3e slicing_correctness\n    subgraph slicing_correctness[Slicing for Correctness]\n        verifies1_slice[[Slice statements]]\n        verifies1_slice --\x3e verifies1_slice\n        verifies1_done[/Minimal verifying slice/]\n        verifies1_slice --\x3e verifies1_done\n        verifies1_conclusion{Selection <br>assume-like?}\n        verifies1_done --\x3e verifies1_conclusion\n        verifies1_concordant[/Program also verifies <br>with less assumptions/]\n        verifies1_unknown[/New verifying program/]\n        verifies1_conclusion --Yes --\x3e verifies1_concordant\n        verifies1_conclusion --No --\x3e verifies1_unknown\n    end"}),(0,r.kt)("h2",{id:"slicing-for-errors"},"Slicing for Errors"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Slicing for errors")," takes a HeyVL program and tries to remove as many statements from the ",(0,r.kt)("em",{parentName:"p"},"slice selection")," as possible such that the resulting program fails verification with a counter-example."),(0,r.kt)("h3",{id:"assertion-slicing"},"Assertion Slicing"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Assertion slicing")," is program slicing with the specific purpose of interpreting counter-examples for verification from the SMT solver.\nThe slice selection consists of all ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),"-like statements (cf. ",(0,r.kt)("a",{parentName:"p",href:"#a-theory-of-slicing-for-heyvl"},(0,r.kt)("em",{parentName:"a"},"A Theory of Slicing for HeyVL"))," for details)."),(0,r.kt)("p",null,"Consider the following HeyVL proc which does not verify:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc two_asserts(x: UInt) -> ()\n{\n    assert ?(x >= 0)\n    assert ?(x >= 1)\n}\n")),(0,r.kt)("p",null,"Clearly, the first assertion is not a problem since all ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt")," values are non-negative.\nThe second one fails when the input is ",(0,r.kt)("inlineCode",{parentName:"p"},"x = 0"),".\nThe SMT solver will indeed give us that counter-example, but we still need to associate this counter-example to a specific assertion.\nWhile we can simply try to evaluate all assertions in state ",(0,r.kt)("inlineCode",{parentName:"p"},"x = 0")," for this example, this becomes impossible when we do not know what the exact state will be in a later statement.\nThis can happen after nondeterministic and probabilistic choices, or after unbounded loops."),(0,r.kt)("p",null,"Caesar instead looks at different counterfactuals for the current verification problem."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Does a verification failure still occur with the first assert removed? Yes."),(0,r.kt)("li",{parentName:"ol"},"Does a verification failure still occur with the second assert removed? No.")),(0,r.kt)("p",null,"From this we can conclude that the second assert is at fault and ",(0,r.kt)("em",{parentName:"p"},"responsible")," for the verification failure.\nIn general, Caesar will try to find a minimal ",(0,r.kt)("em",{parentName:"p"},"set")," of assertions that will lead to a verification error.\nThe result is an error message like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program.heyvl::two_asserts: Counter-example to verification found!\n    input variables:\n        x: 0                                       (program.heyvl:1:12)\n\n    the pre-quantity evaluated to:\n        0\n\n    program slice:\n        \u274c assertion might not hold                  (program.heyvl:4:5)\n")),(0,r.kt)("p",null,'This message\'s "program slice" section points to the second assertion in line 4.'),(0,r.kt)("p",null,"Note that the minimal sets of assertions from counter-examples are not necessarily unique!\nThere might be even more verification failures after the assertions from slicing are removed.\nThe program slice from slicing for errors only constitutes a set from which no assertion can be removed while still getting an error (hence, ",(0,r.kt)("em",{parentName:"p"},"minimal"),")."),(0,r.kt)("p",null,"In theory, we could also look at assertions which are not present in ",(0,r.kt)("em",{parentName:"p"},"any")," minimal slice for errors to determine assertions which are ",(0,r.kt)("em",{parentName:"p"},"never")," a problem.\nHowever, we have not found this useful and have not looked at this further."),(0,r.kt)("h3",{id:"general-slicing-for-errors"},"General Slicing for Errors"),(0,r.kt)("p",null,"Only trying to remove ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),"-like statements may be too restrictive for certain applications.\nConsider the following simple example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc assign_error() -> (x: UInt) {\n    x = 2\n    x = x * 2\n    x = x * 2\n    x = x * 2\n    assert ?(x < 8)\n}\n")),(0,r.kt)("p",null,"This example will fail to verify since ",(0,r.kt)("inlineCode",{parentName:"p"},"x = 16")," holds at the ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),".\nCaesar will also report the assertion as the culprit, but which assignments are problematic?"),(0,r.kt)("p",null,"We can annotate the assignments to instruct Caesar to also try to remove them to still get a counterexample (cf. ",(0,r.kt)("a",{parentName:"p",href:"#slicing-annotations"},"slicing annotations documentation"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},'proc assign_error() -> (x: UInt) {\n    x = 2\n    @slice_error {\n        @error_msg("first needed") x = x * 2\n        @error_msg("second needed") x = x * 2\n        @error_msg("third needed") x = x * 2\n    }\n    assert ?(x < 8)\n}\n')),(0,r.kt)("p",null,"The result is something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program.heyvl::assign_error: Counter-example to verification found!\n    the pre-quantity evaluated to:\n        0\n\n    program slice:\n        \u274c first needed                             (program.heyvl:4:36)\n        \u274c third needed                             (program.heyvl:6:36)\n        \u274c assertion might not hold                  (program.heyvl:8:5)\n")),(0,r.kt)("p",null,"While this example is somewhat silly, one can imagine a more complicated example where removing assignments might be helpful to narrow down the problem."),(0,r.kt)("p",null,"You may ask: why do we not try slice assignments by default?\nThe answer is that assignments are not ",(0,r.kt)("em",{parentName:"p"},"discordant")," according to our ",(0,r.kt)("a",{parentName:"p",href:"#a-theory-of-slicing-for-heyvl"},(0,r.kt)("em",{parentName:"a"},"theory of slicing for HeyVL")),", i.e. removing them does not allow us to conclude something about the original program directly.\nIn general, a counterexample of a HeyVL program with a removed assertion might imply that the original also has a counterexample (as is the case here), but it could also not imply it.\nIt might even imply that the original program verified!\nConsider a program like ",(0,r.kt)("inlineCode",{parentName:"p"},"x = true; x = !x; assert ?(x)")," for example."),(0,r.kt)("h2",{id:"slicing-for-correctness"},"Slicing for Correctness"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Slicing for correctness")," takes a HeyVL program and tries to remove as many statements from the ",(0,r.kt)("em",{parentName:"p"},"slice selection")," as possible such that the resulting program verifies."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"The current implementation of slicing for correctness is ",(0,r.kt)("strong",{parentName:"p"},"unsound")," for programs that contain ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/domains"},"uninterpreted functions"),".\nThis unsoundness also follows for assumption slicing.\nNote that uninterpreted functions may also be generated internally for ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/expressions#quantifiers"},"quantitative quantifiers")," if they are not eliminated by Caesar's quantifier elimination procedure.\nIf you enable ",(0,r.kt)("inlineCode",{parentName:"p"},"--slice-verify"),", you must currently ",(0,r.kt)("strong",{parentName:"p"},"check yourself")," that you do not use uninterpreted functions.")),(0,r.kt)("h3",{id:"assumption-slicing"},"Assumption Slicing"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Assumption slicing")," selects all ",(0,r.kt)("inlineCode",{parentName:"p"},"assume"),"-like statements as candidates to remove from the program and slices so that the resulting program verifies.\nAfter this process, we can get a minimal set of assumptions which are needed for the program to still verify.\nFrom the set of assumptions which are ",(0,r.kt)("em",{parentName:"p"},"not")," included in the minimal necessary slice to verify, we can generate warnings which might indicate a problem to the user.\nFor example we might find out that a pre to a proc is not necessary."),(0,r.kt)("p",null,"Consider the following program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc assumes(x: UInt) -> ()\n    pre ?(x == 42)\n{\n    assume 0\n    assert ?(x >= 1)\n}\n")),(0,r.kt)("p",null,"Caesar will emit an output similar to this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program.heyvl::assumes: Verified.\n    program slice:\n        \ud83e\udd37 assumption is not necessary              (program.heyvl:4:5)\n")),(0,r.kt)("p",null,"As is the case in ",(0,r.kt)("a",{parentName:"p",href:"#assertion-slicing"},"assertion slicing"),", the minimal set of assumptions is not necessarily unique.\nWe also do not search for assumptions which are included in no minimal set of assumptions, instead for just one minimal set from which we cannot remove an assumption without the program not verifying."),(0,r.kt)("h3",{id:"general-slicing-for-correctness"},"General Slicing for Correctness"),(0,r.kt)("p",null,"Consider the following example, in which we sample two bits with fair coin flips.\nThe specification says that the probability of a value of the sampled value ",(0,r.kt)("inlineCode",{parentName:"p"},"r >= 2")," is at least ",(0,r.kt)("inlineCode",{parentName:"p"},"1/2"),".\nThe specification holds, but only one assignment is actually necessary!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"proc bits() -> (r: EUReal)\n    pre 1/2\n    post [r >= 2]\n{\n    var b0: UInt; var b1: UInt\n\n    @slice_verify() {\n        var choice: Bool = flip(0.5)\n        if choice { b0 = 0 } else { b0 = 1 }\n        choice = flip(0.5)\n        if choice { b1 = 0 } else { b1 = 1 }\n        r = b0 + 2 * b1\n    }\n}\n")),(0,r.kt)("p",null,"Running Caesar with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--slice-verify")," option on this program, we get the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program.heyvl::bits: Verified.\n    program slice:\n        \ud83e\udd37 statement in line 9 is not necessary       (program.heyvl:9:21)\n        \ud83e\udd37 statement in line 9 is not necessary       (program.heyvl:9:37)\n        \ud83e\udd37 statement in line 11 is not necessary     (program.heyvl:11:21)\n")),(0,r.kt)("p",null,"From this we can conclude that all but the ",(0,r.kt)("inlineCode",{parentName:"p"},"b1 = 1")," assignment are actuallly not necessary to satisfy the specification."),(0,r.kt)("p",null,"Analogous to the case in ",(0,r.kt)("a",{parentName:"p",href:"#general-slicing-for-errors"},"general slicing for errors"),", we need to explicitly instruct Caesar to try to remove assignments during slicing for correctness using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@slice_verify")," annotation (cf. ",(0,r.kt)("a",{parentName:"p",href:"#slicing-selections"},"slice selection annotations"),").\nIf Caesar tried to remove all assignments by default, we would not necessarily gain any knowledge about the original program.\nMore details in the ",(0,r.kt)("a",{parentName:"p",href:"#a-theory-of-slicing-for-heyvl"},"theory of slicing for HeyVL"),"."),(0,r.kt)("h2",{id:"slicing-annotations"},"Slicing Annotations"),(0,r.kt)("p",null,"For both slicing for errors and correctness, Caesar has some built-in defaults.\nThis includes a default ",(0,r.kt)("em",{parentName:"p"},"slice selection"),' and messages for the statements (such as "assertion might not hold").\nThese defaults can be overwritten by annotations on statements.\nInternally, Caesar also uses these statements, e.g. in the generated encodings for ',(0,r.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules")," to attach messages to statements such as an assertion for an inductiveness check of a loop."),(0,r.kt)("p",null,"The annotations can be added to blocks and compositional statements such as ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),"-statements and will be inherited by all sub-statements."),(0,r.kt)("h3",{id:"slicing-message-annotations"},"Slicing Message Annotations"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@error_msg")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"@success_msg")," annotations can be used to attach messages in case a statement is sliced for errors and correctness, respectively.\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},'proc two_asserts(x: UInt) -> ()\n{\n    @error_msg("x at least zero not necessary") assert ?(x >= 0)\n    @error_msg("x at least one not necessary") assert ?(x >= 1)\n}\n')),(0,r.kt)("p",null,"Will result in the following section in the counter-example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[...]\n    program slice:\n        \u274c x at least one does not hold             (program.heyvl:4:48)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@success_msg")," annotation is used in the same way."),(0,r.kt)("p",null,"Tip: You can inspect the internally generated slicing message annotations from built-in proof rules by passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"--print-core-procs")," command-line option to Caesar."),(0,r.kt)("h3",{id:"slicing-selections"},"Slicing Selections"),(0,r.kt)("p",null,"By default, Caesar selects ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),'-like statements ("discordant") for slicing for errors and ',(0,r.kt)("inlineCode",{parentName:"p"},"assume"),'-like statements ("concordant") for slicing for correctness.\nThe terms ',(0,r.kt)("em",{parentName:"p"},"discordant")," and ",(0,r.kt)("em",{parentName:"p"},"concordant")," are defined in our ",(0,r.kt)("a",{parentName:"p",href:"#a-theory-of-slicing-for-heyvl"},"theory of slicing for HeyVL"),"."),(0,r.kt)("p",null,"In addition to these defaults, Caesar has annotations to add other statements to the slice selection:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@slice_verify"),": Also slice this statement during ",(0,r.kt)("em",{parentName:"li"},"slicing for correctness"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@slice_error"),": Also slice this statement during ",(0,r.kt)("em",{parentName:"li"},"slicing for errors"),".")),(0,r.kt)("p",null,"Note that these annotations will enable slicing for individual sub-statements, not whole blocks."),(0,r.kt)("h2",{id:"a-theory-of-slicing-for-heyvl"},"A Theory of Slicing for HeyVL"),(0,r.kt)("p",null,'When is it "correct" to slice a statement?\nWhat does it mean if we know a statement has been removed from the program?\nOur theory of slicing for HeyVL aims to give clear correctness criteria for slicing.'),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The theory is based on the verification condition semantics of HeyVL.\nYou can find some information in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/statements"},"statements documentation")," and all relevant formal background in our ",(0,r.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"OOPSLA '23 paper"),".\nWe are working on an academic publication about these ideas that goes into more detail.")),(0,r.kt)("h3",{id:"slice-effects"},"Slice Effects"),(0,r.kt)("p",null,"At the core of our theory of slicing for HeyVL are ",(0,r.kt)("em",{parentName:"p"},"slice effects"),", which categorize each HeyVL statement into one of three categories: ",(0,r.kt)("em",{parentName:"p"},"concordant"),", ",(0,r.kt)("em",{parentName:"p"},"discordant"),", and ",(0,r.kt)("em",{parentName:"p"},"ambiguous"),".\nYou can think of ",(0,r.kt)("em",{parentName:"p"},"concordant")," statements as ",(0,r.kt)("em",{parentName:"p"},"like assumptions")," and of ",(0,r.kt)("em",{parentName:"p"},"discordant")," statements as ",(0,r.kt)("em",{parentName:"p"},"like assertions"),".\nSlice effects depend on the current ",(0,r.kt)("em",{parentName:"p"},"direction")," in which we verify.\nIn a ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),", our direction is ",(0,r.kt)("em",{parentName:"p"},"down")," (",(0,r.kt)("em",{parentName:"p"},"lower bounds"),"), and in a ",(0,r.kt)("inlineCode",{parentName:"p"},"coproc"),", the direction is ",(0,r.kt)("em",{parentName:"p"},"up")," (",(0,r.kt)("em",{parentName:"p"},"upper bounds"),")."),(0,r.kt)("p",null,"Formally, we define ",(0,r.kt)("em",{parentName:"p"},"concordant"),"  and ",(0,r.kt)("em",{parentName:"p"},"discordant")," as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"proc"),"s:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A statement ",(0,r.kt)("inlineCode",{parentName:"li"},"S")," is ",(0,r.kt)("em",{parentName:"li"},"concordant")," when for all ",(0,r.kt)("inlineCode",{parentName:"li"},"post")," it holds that ",(0,r.kt)("inlineCode",{parentName:"li"},"post = vc[skip](post) <= vc[S](post)"),"."),(0,r.kt)("li",{parentName:"ul"},"A statement ",(0,r.kt)("inlineCode",{parentName:"li"},"S")," is ",(0,r.kt)("em",{parentName:"li"},"discordant")," when for all ",(0,r.kt)("inlineCode",{parentName:"li"},"post")," it holds that ",(0,r.kt)("inlineCode",{parentName:"li"},"post = vc[skip](post) >= vc[S](post)"),"."))),(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"coproc"),"s, the definitions are reversed:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A statement ",(0,r.kt)("inlineCode",{parentName:"li"},"S")," is ",(0,r.kt)("em",{parentName:"li"},"concordant")," when for all ",(0,r.kt)("inlineCode",{parentName:"li"},"post")," it holds that ",(0,r.kt)("inlineCode",{parentName:"li"},"post = vc[skip](post) >= vc[S](post)"),"."),(0,r.kt)("li",{parentName:"ul"},"A statement ",(0,r.kt)("inlineCode",{parentName:"li"},"S")," is ",(0,r.kt)("em",{parentName:"li"},"discordant")," when for all ",(0,r.kt)("inlineCode",{parentName:"li"},"post")," it holds that ",(0,r.kt)("inlineCode",{parentName:"li"},"post = vc[skip](post) <= vc[S](post)"),".")))),(0,r.kt)("p",null,"Informally, introducing ",(0,r.kt)("em",{parentName:"p"},"concordant"),"  will make them only ",(0,r.kt)("em",{parentName:"p"},"verify more"),", i.e. the ",(0,r.kt)("inlineCode",{parentName:"p"},"vc")," semantics will at most increase in ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),"s (or at least decrease in ",(0,r.kt)("inlineCode",{parentName:"p"},"coproc"),"s).\nThis means if we removed them, we can re-insert concordant statements and the program will still verify.\nOn the other hand, ",(0,r.kt)("em",{parentName:"p"},"discordant")," statements will make programs ",(0,r.kt)("em",{parentName:"p"},"verify less"),", i.e. the ",(0,r.kt)("inlineCode",{parentName:"p"},"vc")," semantics will at most decrease in ",(0,r.kt)("inlineCode",{parentName:"p"},"proc"),"s (or at least increase in ",(0,r.kt)("inlineCode",{parentName:"p"},"coproc"),"s).\nThat means if we removed them, we can re-insert concordant statements and if the sliced program failed to verify, the original program will also fail to verify."),(0,r.kt)("p",null,"Below is a table of HeyVL statements and their slice effects.\nIt should be pretty intuitive: ",(0,r.kt)("inlineCode",{parentName:"p"},"assume")," statements are concordant with respect to lower bounds, and ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"havoc"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"validate")," are discordant.\nWhen they're used in upper bound contexts, then their effects are reversed.\nFor the ",(0,r.kt)("inlineCode",{parentName:"p"},"co"),"-statements, the situation is also exactly reversed."),(0,r.kt)(i.Fragment,null,(0,r.kt)("table",{style:{float:"left","padding-right":"2em"}},(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Statement"),(0,r.kt)("td",null,(0,r.kt)("code",null,"proc")),(0,r.kt)("td",null,(0,r.kt)("code",null,"coproc")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"assume")),(0,r.kt)("td",null,"Concordant"),(0,r.kt)("td",null,"Discordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"assert")),(0,r.kt)("td",null,"Discordant"),(0,r.kt)("td",null,"Concordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"havoc")),(0,r.kt)("td",null,"Discordant"),(0,r.kt)("td",null,"Concordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"validate")),(0,r.kt)("td",null,"Discordant"),(0,r.kt)("td",null,"Concordant")))),(0,r.kt)("table",{style:{float:"left"}},(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Statement"),(0,r.kt)("td",null,(0,r.kt)("code",null,"proc")),(0,r.kt)("td",null,(0,r.kt)("code",null,"coproc")))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"coassume")),(0,r.kt)("td",null,"Discordant"),(0,r.kt)("td",null,"Concordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"coassert")),(0,r.kt)("td",null,"Concordant"),(0,r.kt)("td",null,"Discordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"cohavoc")),(0,r.kt)("td",null,"Concordant"),(0,r.kt)("td",null,"Discordant")),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("code",null,"covalidate")),(0,r.kt)("td",null,"Concordant"),(0,r.kt)("td",null,"Discordant")))),(0,r.kt)("div",{style:{clear:"both"}})),(0,r.kt)("p",null,"Note that Caesar only tries to slice ",(0,r.kt)("inlineCode",{parentName:"p"},"(co)assume")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"(co)assert")," statements, but not ",(0,r.kt)("inlineCode",{parentName:"p"},"(co)havoc")," nor ",(0,r.kt)("inlineCode",{parentName:"p"},"(co)validate"),"."),(0,r.kt)("h2",{id:"implementation-details"},"Implementation Details"),(0,r.kt)("p",null,"Caesar's implementation of slicing is a two-stage approach.\nIt first does a ",(0,r.kt)("a",{parentName:"p",href:"#program-transformation"},"program transformation")," to prepare the input program for slicing.\nThen we use the SMT solver to minimize the number of enabled statements in the slice in the ",(0,r.kt)("a",{parentName:"p",href:"#solving-for-minimal-slices"},"solving for minimal slices")," stage."),(0,r.kt)("h3",{id:"program-transformation"},"Program Transformation"),(0,r.kt)("p",null,"To prepare a HeyVL program for slicing, Caesar starts with a ",(0,r.kt)("em",{parentName:"p"},"slice selection")," of potential statements to slice.\nUsually, that's discordant statements and those enabled with explicit ",(0,r.kt)("a",{parentName:"p",href:"#slicing-selections"},"slice selection annotations"),".\nIf the option ",(0,r.kt)("inlineCode",{parentName:"p"},"--slice-verify")," is set, then we also transform concordant statements as well."),(0,r.kt)("p",null,"For each potentially sliceable statement ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),", we create a new Boolean input variable ",(0,r.kt)("inlineCode",{parentName:"p"},"slice_S")," to the program.\nThe statement ",(0,r.kt)("inlineCode",{parentName:"p"},"S_i")," is (logically) replaced by ",(0,r.kt)("inlineCode",{parentName:"p"},"if slice_i { S } else {}"),".\nIn the implementation, we have specialized transformations for almost all kinds of statements to avoid exponential blow-up of the generated verification conditions."),(0,r.kt)("p",null,"Consider an assumption ",(0,r.kt)("inlineCode",{parentName:"p"},"assume f"),".\nIf we just wrapped it into an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," statement, then we would get verification conditions that contain the post twice:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vc[if slice_1 { assume f } else {}](post) = ite(slice_1, f ==> post, post)\n")),(0,r.kt)("p",null,"However, we do an equivalent transformation so that the post is not duplicated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vc[assume ite(slice_1, f, 0)](post) = (ite(slice_1, f, 0) ==> post)\n")),(0,r.kt)("h3",{id:"solving-for-minimal-slices"},"Solving for Minimal Slices"),(0,r.kt)("p",null,"After this program transformation, every potentially sliceable statement is associated with a Boolean variable that we can use to turn it on or off.\nThat means we can just set constraints on the number of enabled statements in the SMT solver to query for a new slice.\nWe do ",(0,r.kt)("em",{parentName:"p"},"not")," need to re-generate verification conditions, nor do we re-do our optimizations.\nThis allows us to take advantage of the abilities of modern SMT solvers to try a lot of Boolean combinations very quickly."),(0,r.kt)("p",null,"When we ",(0,r.kt)("a",{parentName:"p",href:"#slicing-for-errors"},"slice for errors"),", we can generate a nice exists-exists query that looks for a counter-example to verification with an assignment to the enabled variables.\nIt is of the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"exists slice_1,...,slice_n: exists initial_state: vc[S](\\infty) != \\infty\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#slicing-for-correctness"},"Slicing for correctness")," unfortunately generates a quantifier alternation.\nWe ask the SMT solver to find an assignment to the slice variables such that ",(0,r.kt)("em",{parentName:"p"},"for all")," initial states the program verifies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"exists slice_1,...,slice_n: forall initial_state: vc[S](\\infty) == \\infty\n")),(0,r.kt)("p",null,'After building these new verification queries for slicing, we minimize the number of enabled statements by iteratively asking the SMT solver for a solution with a smaller number of enabled slice variables.\nWe do a kind of binary search that takes into account the possibility of an "unknown" result from the SMT solver.'),(0,r.kt)("p",null,"As far as we could tell, using e.g. Z3's built-in optimizer for these tasks is often infeasible as it is restricted to a (not particularly well-defined) fragment of input formulas and ",(0,r.kt)("em",{parentName:"p"},"may return unsound results"),' on other inputs.\nIt also seems to be designed to find actually optimal results, whereas we are also happy with a "good" result if some timeout expires.'))}f.isMDXComponent=!0}}]);