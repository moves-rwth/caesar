"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[1600],{256:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/06/10/caesar-at-ssft-25","editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/blog/2025-06-10-caesar-at-ssft-25.md","source":"@site/blog/2025-06-10-caesar-at-ssft-25.md","title":"Caesar at Summer School for Formal Techniques \'25","description":"We had the pleasure to present Caesar at the 14th Summer School for Formal Techniques at Menlo College in Menlo Park, California, organized by the SRI Formal Methods Group.","date":"2025-06-10T00:00:00.000Z","tags":[{"inline":true,"label":"talks","permalink":"/blog/tags/talks"}],"readingTime":1.97,"hasTruncateMarker":true,"authors":[{"name":"Philipp Schroer","title":"Caesar Developer","url":"https://moves.rwth-aachen.de/people/philipp-schroer/","imageURL":"https://github.com/Philipp15b.png","key":"phisch","page":null}],"frontMatter":{"authors":"phisch","tags":["talks"]},"unlisted":false,"prevItem":{"title":"Caesar 3.0: Better Reasoning with Limited Functions","permalink":"/blog/2025/07/29/caesar-3-0"},"nextItem":{"title":"Caesar 2.2: Timeout Handling, Recursion Checks, Improved Model Checking, and More","permalink":"/blog/2025/05/23/caesar-2-2"}}')},4005:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var r=a(256),o=a(4848),s=a(8453);const n={authors:"phisch",tags:["talks"]},i="Caesar at Summer School for Formal Techniques '25",l={authorsImageUrls:[void 0]},c=[];function h(e){const t={a:"a",blockquote:"blockquote",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["We had the pleasure to present Caesar at the 14th ",(0,o.jsx)(t.a,{href:"https://ssft-sri.github.io/",children:"Summer School for Formal Techniques"})," at Menlo College in Menlo Park, California, organized by the ",(0,o.jsx)(t.a,{href:"https://www.csl.sri.com/programs/formalmethods/",children:"SRI Formal Methods Group"}),".\nIt took place from May 24th to May 30th."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://moves.rwth-aachen.de/people/katoen/",children:"Joost-Pieter Katoen"})," gave two lectures on the theoretical foundations of probabilistic programming and their verification, and together we hosted two accompanying lab sessions where students could try out Caesar and HeyVL."]}),"\n",(0,o.jsx)(t.p,{children:"Here is the lecture abstract:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'Probabilistic programs encode randomized algorithms, robot controllers, learning components, security mechanisms, and much more. They are however hard to grasp. Not only by humans, also by computers: checking elementary properties related to e.g., termination are "more undecidable" than for ordinary programs. The analysis of probabilistic programs requires manipulating irrational or even transcendental numbers.'}),"\n",(0,o.jsx)(t.p,{children:"Although this all sounds like a no-go for (semi-)automated analysis, I will present a deductive verification technique to analyse probabilistic programs. In contrast to simulation (like MCMC), this analysis yields exact results. Our technique is based on weakest precondition reasoning. We will explain the foundations of this approach, present some proof rules to reason about probabilistic while-loops, and discuss how the analysis can be automated \u2014 either fully or with the help of invariants."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.a,{href:"/blog/2025/06/10/caesar-at-ssft-25#materials",children:"material is available online"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>n,x:()=>i});var r=a(6540);const o={},s=r.createContext(o);function n(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);