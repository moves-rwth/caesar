"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[9760],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7723:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={description:"Statements are executed sequentially and may have side-effects.",sidebar_position:2},i="Statements",s={unversionedId:"heyvl/statements",id:"heyvl/statements",title:"Statements",description:"Statements are executed sequentially and may have side-effects.",source:"@site/docs/heyvl/statements.md",sourceDirName:"heyvl",slug:"/heyvl/statements",permalink:"/docs/heyvl/statements",draft:!1,editUrl:"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/statements.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"Statements are executed sequentially and may have side-effects.",sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Procedures",permalink:"/docs/heyvl/procs"},next:{title:"Expressions",permalink:"/docs/heyvl/expressions"}},l={},p=[{value:"Semantics",id:"semantics",level:2},{value:"Blocks",id:"blocks",level:2},{value:"Variable Declarations",id:"variable-declarations",level:2},{value:"Assignments",id:"assignments",level:2},{value:"Havoc",id:"havoc",level:2},{value:"Assert and Assume",id:"assert-and-assume",level:2},{value:"Reward (formerly Tick)",id:"reward-formerly-tick",level:2},{value:"Nondeterministic Choices",id:"nondeterministic-choices",level:2},{value:"Boolean Choices",id:"boolean-choices",level:2},{value:"While Loops",id:"while-loops",level:2},{value:"Deprecated Statements",id:"deprecated-statements",level:2},{value:"Compare",id:"compare",level:3},{value:"Negations",id:"negations",level:3}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"statements"},"Statements"),(0,r.kt)("p",null,"Statements in HeyVL are instructions that are interpreted sequentially and that have side-effects.\nThey are used inside the body of ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/procs"},"procedures"),"."),(0,r.kt)("h2",{id:"semantics"},"Semantics"),(0,r.kt)("p",null,"Since HeyVL is an intermediate verification language, not all statements allow an operational interpretation of their effects.\nAll HeyVL statements should be understood through their (quantitative) verification condition semantics.\nThese are defined in reverse order, starting from an initial verification condition and proceeding from the last statement backwards to the front.\nWe describe the ",(0,r.kt)("em",{parentName:"p"},"formal semantics of HeyVL statements")," ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2309.07781.pdf#page=10"},"in our paper on Caesar (cf. Section 3)"),"."),(0,r.kt)("h2",{id:"blocks"},"Blocks"),(0,r.kt)("p",null,"A block is a sequence of statements enclosed by curly braces.\nStatements ",(0,r.kt)("em",{parentName:"p"},"may")," be separated by semicolons, but those can be omitted.\nEach block creates a ",(0,r.kt)("em",{parentName:"p"},"local scope")," into which variables are declared.\nBlocks can be nested.\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"x = 1\n{\n    var y: UInt\n}\ny = 1 // y is not declared in this scope\n")),(0,r.kt)("h2",{id:"variable-declarations"},"Variable Declarations"),(0,r.kt)("p",null,"A variable declaration ",(0,r.kt)("inlineCode",{parentName:"p"},"var name: Type")," creates a new local variable in the current scope.\nA variable declaration can be combined with an assignment to initialize the variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"var forty_two: UInt = 42\n")),(0,r.kt)("h2",{id:"assignments"},"Assignments"),(0,r.kt)("p",null,"An assignment ",(0,r.kt)("inlineCode",{parentName:"p"},"x = 39 + y")," evaluates the expression on the right-hand side in the current state and assigns the result to the variable on the left-hand side."),(0,r.kt)("p",null,"The left-hand side of an assignment may be a list of variables to unpack a tuple.\nFor example, imagine a procedure ",(0,r.kt)("inlineCode",{parentName:"p"},"two_numbers")," whose return type is ",(0,r.kt)("inlineCode",{parentName:"p"},"(x: UInt, y: UInt)"),".\nThe following statement assigns the result of a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"two_numbers")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"x, y = two_numbers()\n")),(0,r.kt)("p",null,"If the right-hand side of the assignment is a (pure) expression, then the verification condition semantics amounts to a substitution of the left-hand side by the right-hand side."),(0,r.kt)("p",null,"If the right-hand side is a call to a procedure, then the assignment is translated to a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"havoc"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"compare")," statements.\nSee the ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/procs"},"reference on procedures")," for more information."),(0,r.kt)("p",null,"If the procedure does not have any return values, the call may be written without the equals sign and the left-hand side, i.e. simply ",(0,r.kt)("inlineCode",{parentName:"p"},"fn(arg1, arg2)"),"."),(0,r.kt)("h2",{id:"havoc"},"Havoc"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"havoc"),' statement can be used to "forget" previous values of variables in the following code.\nIt also comes in a ',(0,r.kt)("inlineCode",{parentName:"p"},"co")," variant."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"havoc x, y, z\ncohavoc a, b, c\n")),(0,r.kt)("p",null,"The verification condition semantics of ",(0,r.kt)("inlineCode",{parentName:"p"},"havoc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cohavoc")," create an infimum respectively supremum over the specified variables."),(0,r.kt)("h2",{id:"assert-and-assume"},"Assert and Assume"),(0,r.kt)("p",null,"These statements generate binary operators in the verification condition semantics.\nAll three statements also come in ",(0,r.kt)("inlineCode",{parentName:"p"},"co")," variants.\n",(0,r.kt)("inlineCode",{parentName:"p"},"(co)assert")," generates an infimum respectively supremum.\n",(0,r.kt)("inlineCode",{parentName:"p"},"(co)assume")," generates an implication respectively co-implication."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"assert 1 + x\nassume 0\n")),(0,r.kt)("h2",{id:"reward-formerly-tick"},"Reward (formerly Tick)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reward")," statement accepts an expression and adds it to the current verification condition.\nFor example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"reward 2 * x\n")),(0,r.kt)("p",null,"has the following semantics: ",(0,r.kt)("inlineCode",{parentName:"p"},"vc[reward 2 * x](f) = f + (2 * x)"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tick")," is another name that Caesar accepts for ",(0,r.kt)("inlineCode",{parentName:"p"},"reward"),"."),(0,r.kt)("h2",{id:"nondeterministic-choices"},"Nondeterministic Choices"),(0,r.kt)("p",null,'HeyVL supports two kinds of binary nondeterministic choices: The "demonic" one (',(0,r.kt)("inlineCode",{parentName:"p"},"if \u2293"),') and the "angelic" one (',(0,r.kt)("inlineCode",{parentName:"p"},"if \u2294"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"if \u2293 {\n    ...\n} else {\n    ...\n}\n")),(0,r.kt)("p",null,"You can also use Latex-style syntax instead of Unicode.\nCaesar supports ",(0,r.kt)("inlineCode",{parentName:"p"},"\\cap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"\\cup")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2293")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2294"),", respectively.\n(We're looking for better syntax for these statements. If you have an idea, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/moves-rwth/caesar/discussions"},"please start a discussion"),".)"),(0,r.kt)("h2",{id:"boolean-choices"},"Boolean Choices"),(0,r.kt)("p",null,"HeyVL supports a binary choice depending on the value of a Boolean expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"if x + 1 == 2 {\n    ...\n} else {\n    ...\n}\n")),(0,r.kt)("h2",{id:"while-loops"},"While Loops"),(0,r.kt)("p",null,"HeyVL supports while loops that run a block of code while a condition evaluates to true."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-heyvl"},"var cont: Bool = true\nwhile cont {\n    cont = flip(0.5)\n}\n")),(0,r.kt)("p",null,"However, for verification while loops need to be annotated with ",(0,r.kt)("a",{parentName:"p",href:"../proof-rules/"},"proof rules"),", otherwise Caesar will show an error.\nThese proof rule annotations also implicitly specify whether the loop has least or greatest fixpoint semantics.\nThis choice can be made explicit with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/proof-rules/calculi"},"calculus annotations")," on procedures, which we recommend you use."),(0,r.kt)("h2",{id:"deprecated-statements"},"Deprecated Statements"),(0,r.kt)("p",null,"Caesar supports some HeyVL statements that are not part of the HeyVL language ",(0,r.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"published in our OOPSLA '23 paper"),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"These statements were used for previous iterations of HeyVL, but may be removed from Caesar at any time.")),(0,r.kt)("h3",{id:"compare"},"Compare"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"compare f")," statement corresponds to an abbreviation of ",(0,r.kt)("inlineCode",{parentName:"p"},"validate; assume f"),"."),(0,r.kt)("p",null,"The dual ",(0,r.kt)("inlineCode",{parentName:"p"},"cocompare f")," statement corresponds to an abbreviation of ",(0,r.kt)("inlineCode",{parentName:"p"},"covalidate; coassume f"),"."),(0,r.kt)("h3",{id:"negations"},"Negations"),(0,r.kt)("p",null,"We have a ",(0,r.kt)("inlineCode",{parentName:"p"},"negate")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"conegate")," statement, whose semantics correspond to HeyLo's negations."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"validate")," statement corresponds to ",(0,r.kt)("inlineCode",{parentName:"p"},"conegate; conegate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"covalidate")," corresponds to ",(0,r.kt)("inlineCode",{parentName:"p"},"negate; negate"),"."),(0,r.kt)("p",null,"It is recommended that you avoid negations for the reasons detailed in the warning below."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Negation statements in HeyVL break ",(0,r.kt)("em",{parentName:"p"},"monotonicity"),", an important property of HeyVL semantics that is required for sound ",(0,r.kt)("a",{parentName:"p",href:"/docs/heyvl/procs#calling-procedures"},"(co)procedure calls"),".\nIf negations are used in such a way that monotonicity is broken, then (co)procedure calls are unsound.\nRefer to our ",(0,r.kt)("a",{parentName:"p",href:"/docs/publications#oopsla-23"},"OOPSLA '23 paper")," for details on monotonicity and soundness of (co)procedure calls.")))}m.isMDXComponent=!0}}]);