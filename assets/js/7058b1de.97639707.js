"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[7079],{396:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"heyvl/expressions","title":"Expressions","description":"HeyVL\'s expressions evaluate to a value in a state.","source":"@site/docs/heyvl/expressions.md","sourceDirName":"heyvl","slug":"/heyvl/expressions","permalink":"/docs/heyvl/expressions","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/heyvl/expressions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"description":"HeyVL\'s expressions evaluate to a value in a state.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Statements","permalink":"/docs/heyvl/statements"},"next":{"title":"Functions, Axioms, and Domains","permalink":"/docs/heyvl/domains"}}');var i=n(4848),t=n(8453);const l={description:"HeyVL's expressions evaluate to a value in a state.",sidebar_position:3},o="Expressions",a={},d=[{value:"Expression Syntax",id:"expression-syntax",level:2},{value:"Semantics and Under-Specified Expressions",id:"semantics-and-under-specified-expressions",level:2},{value:"If-Then-Else",id:"if-then-else",level:2},{value:"Let Expressions",id:"let-expressions",level:2},{value:"Quantifiers",id:"quantifiers",level:2},{value:"Triggers",id:"triggers",level:3},{value:"Relative Completeness",id:"relative-completeness",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"expressions",children:"Expressions"})}),"\n",(0,i.jsxs)(s.p,{children:["HeyVL expressions can be used inside ",(0,i.jsx)(s.a,{href:"/docs/heyvl/procs",children:"specifications"})," and ",(0,i.jsx)(s.a,{href:"/docs/heyvl/statements",children:"statements"})," and evaluate to values in some program state."]}),"\n",(0,i.jsx)(s.h2,{id:"expression-syntax",children:"Expression Syntax"}),"\n",(0,i.jsxs)(s.p,{children:["The syntax of expressions (",(0,i.jsx)(s.code,{children:"Expr"}),") consists of the following parts:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#quantifiers",children:"Quantifiers"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"inf Ident: Type, Ident: Type. Expr"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sup Ident: Type, Ident: Type. Expr"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"forall Ident: Type, Ident: Type. Expr"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"exists Ident: Type, Ident: Type. Expr"})}),"\n",(0,i.jsxs)(s.li,{children:["Quantifier annotations such as ",(0,i.jsx)(s.a,{href:"#triggers",children:"triggers"})," are also allowed, e.g. ",(0,i.jsx)(s.code,{children:"forall Ident: Type @trigger(Expr). Expr"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Boolean Operators (returning ",(0,i.jsxs)(s.a,{href:"/docs/stdlib/booleans",children:["type ",(0,i.jsx)(s.code,{children:"Bool"})]}),"):","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Logical And: ",(0,i.jsx)(s.code,{children:"Expr && Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Logical Or: ",(0,i.jsx)(s.code,{children:"Expr || Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Equals: ",(0,i.jsx)(s.code,{children:"Expr == Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Less Than: ",(0,i.jsx)(s.code,{children:"Expr <= Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Not Equals: ",(0,i.jsx)(s.code,{children:"Expr != Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Greater Or Equals: ",(0,i.jsx)(s.code,{children:"Expr >= Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Greater: ",(0,i.jsx)(s.code,{children:"Expr > Expr"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Binary Lattice and Heyting Algebra Operators (on types ",(0,i.jsx)(s.a,{href:"../stdlib/",children:(0,i.jsx)(s.code,{children:"Bool"})})," and ",(0,i.jsx)(s.a,{href:"/docs/stdlib/numbers#eureal",children:(0,i.jsx)(s.code,{children:"EUReal"})}),"):","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Binary Minimum/Infimum: ",(0,i.jsx)(s.code,{children:"Expr \u2293 Expr"})," or ",(0,i.jsx)(s.code,{children:"Expr \\cap Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Binary Maximum/Supremum: ",(0,i.jsx)(s.code,{children:"Expr \u2294 Expr"})," or ",(0,i.jsx)(s.code,{children:"Expr \\cup Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Implication: ",(0,i.jsx)(s.code,{children:"Expr \u2192 Expr"})," or ",(0,i.jsx)(s.code,{children:"Expr ==> Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Coimplication: ",(0,i.jsx)(s.code,{children:"Expr \u2190 Expr"})," or ",(0,i.jsx)(s.code,{children:"Expr <== Expr"})," ",(0,i.jsxs)("small",{children:["(note that this is ",(0,i.jsx)(s.strong,{children:"not"})," just a flipped version of the implication ",(0,i.jsx)(s.code,{children:"\u2192"}),", but rather its lattice-theoretic dual!)"]})]}),"\n",(0,i.jsxs)(s.li,{children:["Comparison: ",(0,i.jsx)(s.code,{children:"Expr \u2198 Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Cocomparison: ",(0,i.jsx)(s.code,{children:"Expr \u2196 Expr"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Arithmetical Operators (c.f. ",(0,i.jsx)(s.a,{href:"/docs/stdlib/numbers",children:"number types"}),"):","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Addition: ",(0,i.jsx)(s.code,{children:"Expr + Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Subtraction/Monus: ",(0,i.jsx)(s.code,{children:"Expr - Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Multiplication: ",(0,i.jsx)(s.code,{children:"Expr * Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Division: ",(0,i.jsx)(s.code,{children:"Expr / Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Modulo: ",(0,i.jsx)(s.code,{children:"Expr % Expr"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Other Expressions:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#let-expressions",children:"Let Expressions"}),": ",(0,i.jsx)(s.code,{children:"let(Ident, Expr, Expr)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#if-then-else",children:"If-Then-Else Expressions"}),": ",(0,i.jsx)(s.code,{children:"ite(Expr, Expr, Expr)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"/docs/heyvl/domains",children:"Function Calls"}),": ",(0,i.jsx)(s.code,{children:"Ident(Expr, ..., Expr)"})]}),"\n",(0,i.jsxs)(s.li,{children:["Negation: ",(0,i.jsx)(s.code,{children:"!Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Conegation: ",(0,i.jsx)(s.code,{children:"~Expr"})]}),"\n",(0,i.jsxs)(s.li,{children:["Embed: ",(0,i.jsx)(s.code,{children:"?Expr"})," (usually written with parentheses: ",(0,i.jsx)(s.code,{children:"?(Expr)"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Iverson: ",(0,i.jsx)(s.code,{children:"[Expr]"})]}),"\n",(0,i.jsxs)(s.li,{children:["Parentheses: ",(0,i.jsx)(s.code,{children:"(Expr)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Literals:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["String Literals: text enclosed by ",(0,i.jsx)(s.code,{children:'"'})," characters (regular expression: ",(0,i.jsx)(s.code,{children:'"[^"]*"'}),"). ",(0,i.jsxs)("small",{children:["Note that Caesar does not support a proper ",(0,i.jsx)(s.code,{children:"String"})," type yet."]})]}),"\n",(0,i.jsxs)(s.li,{children:["Integers: given by regular expression ",(0,i.jsx)(s.code,{children:"[0-9]+"})," (default type: ",(0,i.jsx)(s.code,{children:"UInt"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Decimals: given by regular expression ",(0,i.jsx)(s.code,{children:"[0-9]+\\.[0-9]+"})," (default type: ",(0,i.jsx)(s.code,{children:"UReal"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Boolean Constants: ",(0,i.jsx)(s.code,{children:"true"})," and ",(0,i.jsx)(s.code,{children:"false"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Identifiers (",(0,i.jsx)(s.code,{children:"Ident"}),"): Names of things, from the language of the regular expression ",(0,i.jsx)(s.code,{children:"[_a-zA-Z][_a-zA-Z0-9']*"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Types (",(0,i.jsx)(s.code,{children:"Type"}),") are types from Caesar's ",(0,i.jsx)(s.a,{href:"../stdlib/",children:"standard library"})," and user-defined types from ",(0,i.jsx)(s.a,{href:"/docs/heyvl/domains",children:"domains"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"The above list is presented roughly in order of operator precedence.\nNote that we plan to change some operator precedences, so when in doubt, use more parentheses to guarantee the correct interpretation."}),"\n",(0,i.jsxs)(s.p,{children:["The most precise grammar specification can be found in Caesar's source code (",(0,i.jsx)(s.a,{href:"https://github.com/moves-rwth/caesar/blob/main/src/front/parser/grammar.lalrpop",children:(0,i.jsx)(s.code,{children:"src/front/parser/grammar.lalrpop"})}),")."]}),"\n",(0,i.jsx)(s.h2,{id:"semantics-and-under-specified-expressions",children:"Semantics and Under-Specified Expressions"}),"\n",(0,i.jsxs)(s.p,{children:["In ",(0,i.jsx)(s.a,{href:"https://arxiv.org/pdf/2309.07781.pdf#page=5",children:"our paper on HeyVL (cf. Section 2)"}),", we give a formal semantics for ",(0,i.jsx)(s.em,{children:"HeyLo"}),", our logic for reasoning about expected values.\nHeyLo includes operators such as ",(0,i.jsx)(s.code,{children:"==>"}),", ",(0,i.jsx)(s.code,{children:"<=="}),", ",(0,i.jsx)(s.code,{children:"!"}),", ",(0,i.jsx)(s.code,{children:"~"}),", ",(0,i.jsx)(s.code,{children:"?(e)"}),", and more.\nCaesar's expressions are a superset of HeyLo.\nIn particular, the paper explains in detail the lattice and Heyting algebra operators that Caesar supports."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that some operations are not fully specified (",(0,i.jsx)(s.em,{children:"under-specified"}),").\nThe division and remainder operators (",(0,i.jsx)(s.code,{children:"Expr / Expr"})," and ",(0,i.jsx)(s.code,{children:"Expr % Expr"}),") are not fully defined for all values.\nCaesar translates these operators directly to SMT, where the SMT solver may assign arbitrary interpretations to e.g. divisions by zero.\nYou can find more information in the ",(0,i.jsx)(s.a,{href:"https://microsoft.github.io/z3guide/docs/theories/Arithmetic/#division",children:"Z3 documentation on division"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"-"})," operator is always fully defined in Caesar.\nOn unsigned types such as ",(0,i.jsx)(s.code,{children:"UInt"}),", it corresponds to ",(0,i.jsx)(s.em,{children:"monus"}),", i.e. truncating subtraction that is always at least ",(0,i.jsx)(s.code,{children:"0"}),".\nOn signed types such as ",(0,i.jsx)(s.code,{children:"Int"}),", it corresponds to the usual subtraction."]}),"\n",(0,i.jsx)(s.h2,{id:"if-then-else",children:"If-Then-Else"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"ite"})," built-in function allows to choose one of two expressions based on the result of a Boolean expression.\nFor example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-heyvl",children:"var x: UInt = ite(true, 32, 64);\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The first parameter is the Boolean expression.\nIf it evaluates to ",(0,i.jsx)(s.code,{children:"true"}),", the result of evaluating the second expression is returned.\nOtherwise, the third expression is evaluated."]}),"\n",(0,i.jsx)(s.h2,{id:"let-expressions",children:"Let Expressions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"let"})," expressions enable the declaration of local variables within an expression.\nFor example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-heyvl",children:"var x: UInt = let(b, true, ite(b, 32, 64));\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"let"})," expression creates a new local variable ",(0,i.jsx)(s.code,{children:"b"})," and sets its value to ",(0,i.jsx)(s.code,{children:"true"}),".\nThis variable ",(0,i.jsx)(s.code,{children:"b"})," is available within the ",(0,i.jsx)(s.code,{children:"let"})," expression's third argument."]}),"\n",(0,i.jsxs)(s.p,{children:["In contrast to variable declaration statements using ",(0,i.jsx)(s.code,{children:"var"}),", ",(0,i.jsx)(s.code,{children:"let"})," expressions do not require type annotations.\nThe type of the variable is inferred from the second expression."]}),"\n",(0,i.jsx)(s.h2,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,i.jsxs)(s.p,{children:["HeyVL features Boolean and quantitative quantifiers: ",(0,i.jsx)(s.code,{children:"forall"}),", ",(0,i.jsx)(s.code,{children:"exists"}),", ",(0,i.jsx)(s.code,{children:"inf"}),", ",(0,i.jsx)(s.code,{children:"sup"}),".\nFor example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-heyvl",children:"forall x: Int, y: UInt. x == y || x != y\n"})}),"\n",(0,i.jsx)(s.h3,{id:"triggers",children:"Triggers"}),"\n",(0,i.jsxs)(s.p,{children:["We also support ",(0,i.jsx)(s.em,{children:"triggers"})," for the Boolean quantifiers via annotations.\nThey are patterns that will instruct the SMT solver to instantiate quantifiers if the pattern is found in the current list of terms it maintains.\nFor example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-heyvl",children:"forall list: []Int @trigger(len(list)). len(list) >= 0\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Multi-patterns"})," are also supported, by writing a comma-separated list inside the ",(0,i.jsx)(s.code,{children:"@trigger"})," annotation:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-heyvl",children:"forall list: []Int @trigger(len(list), len(list)). len(list) >= 0\n"})}),"\n",(0,i.jsxs)(s.p,{children:["For more information on how triggers/patterns work in general, see the ",(0,i.jsx)(s.a,{href:"https://microsoft.github.io/z3guide/docs/logic/Quantifiers/#patterns",children:"Z3 User Guide"})," and the ",(0,i.jsx)(s.a,{href:"https://dafny.org/latest/DafnyRef/DafnyRef#sec-trigger",children:"Dafny documentation"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"relative-completeness",children:"Relative Completeness"}),"\n",(0,i.jsxs)(s.p,{children:["Caesar's expression syntax is based on ",(0,i.jsx)(s.a,{href:"https://dl.acm.org/doi/10.1145/3434320",children:"the expressive assertion language for probabilistic verification by Batz et al"}),".\nIn theory, ",(0,i.jsx)(s.em,{children:"expressiveness"})," means that for many programs and properties, we know that we can express ",(0,i.jsx)(s.em,{children:"all"})," pre-expectations and invariants in the expression syntax when a post-expectation is written in that syntax."]}),"\n",(0,i.jsxs)(s.p,{children:["Formally, we have that the ",(0,i.jsx)(s.a,{href:"/docs/proof-rules/calculi",children:"weakest pre-expectation calculus"})," ",(0,i.jsx)(s.code,{children:"wp"})," is ",(0,i.jsx)(s.em,{children:"relatively complete"})," with respect to this language, which means that ",(0,i.jsx)(s.code,{children:"wp[P](post)"})," is effectively constructible for all programs ",(0,i.jsx)(s.code,{children:"P"})," and expectations ",(0,i.jsx)(s.code,{children:"post"})," in their syntax."]}),"\n",(0,i.jsxs)(s.p,{children:["Their syntax includes enough constructs to specify many interesting properties, such as termination probabilities or the distribution over final states, even including stuff like harmonic numbers.\nSee ",(0,i.jsx)(s.a,{href:"https://dl.acm.org/doi/pdf/10.1145/3434320#page=26",children:"the paper's Section 12 for more details"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Of course, this does not mean that all of these verification problems are decidable.\nIt just means that in theory, the undecidable part is ",(0,i.jsx)(s.em,{children:"only"})," in the final inequality check ",(0,i.jsx)(s.code,{children:"pre <= wp[P](post)"})," instead of the computation of ",(0,i.jsx)(s.code,{children:"wp[P](post)"}),".\n",(0,i.jsx)(s.a,{href:"/docs/caesar/debugging#incompleteness",children:"The section on SMT theories and incompleteness"})," specifies which of these inequalities are actually decidable with Caesar."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>o});var r=n(6540);const i={},t=r.createContext(i);function l(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);