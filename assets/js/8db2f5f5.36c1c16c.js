"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[5079],{256:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/06/10/caesar-at-ssft-25","editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/blog/2025-06-10-caesar-at-ssft-25.md","source":"@site/blog/2025-06-10-caesar-at-ssft-25.md","title":"Caesar at Summer School for Formal Techniques \'25","description":"We had the pleasure to present Caesar at the 14th Summer School for Formal Techniques at Menlo College in Menlo Park, California, organized by the SRI Formal Methods Group.","date":"2025-06-10T00:00:00.000Z","tags":[{"inline":true,"label":"talks","permalink":"/blog/tags/talks"}],"readingTime":1.97,"hasTruncateMarker":true,"authors":[{"name":"Philipp Schroer","title":"Caesar Developer","url":"https://moves.rwth-aachen.de/people/philipp-schroer/","imageURL":"https://github.com/Philipp15b.png","key":"phisch","page":null}],"frontMatter":{"authors":"phisch","tags":["talks"]},"unlisted":false,"prevItem":{"title":"Caesar 3.0: Better Reasoning with Limited Functions","permalink":"/blog/2025/07/29/caesar-3-0"},"nextItem":{"title":"Caesar 2.2: Timeout Handling, Recursion Checks, Improved Model Checking, and More","permalink":"/blog/2025/05/23/caesar-2-2"}}')},7539:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>a,toc:()=>h});var a=r(256),s=r(4848),i=r(8453);const n={authors:"phisch",tags:["talks"]},o="Caesar at Summer School for Formal Techniques '25",l={authorsImageUrls:[void 0]},h=[{value:"Materials",id:"materials",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["We had the pleasure to present Caesar at the 14th ",(0,s.jsx)(t.a,{href:"https://ssft-sri.github.io/",children:"Summer School for Formal Techniques"})," at Menlo College in Menlo Park, California, organized by the ",(0,s.jsx)(t.a,{href:"https://www.csl.sri.com/programs/formalmethods/",children:"SRI Formal Methods Group"}),".\nIt took place from May 24th to May 30th."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://moves.rwth-aachen.de/people/katoen/",children:"Joost-Pieter Katoen"})," gave two lectures on the theoretical foundations of probabilistic programming and their verification, and together we hosted two accompanying lab sessions where students could try out Caesar and HeyVL."]}),"\n",(0,s.jsx)(t.p,{children:"Here is the lecture abstract:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:'Probabilistic programs encode randomized algorithms, robot controllers, learning components, security mechanisms, and much more. They are however hard to grasp. Not only by humans, also by computers: checking elementary properties related to e.g., termination are "more undecidable" than for ordinary programs. The analysis of probabilistic programs requires manipulating irrational or even transcendental numbers.'}),"\n",(0,s.jsx)(t.p,{children:"Although this all sounds like a no-go for (semi-)automated analysis, I will present a deductive verification technique to analyse probabilistic programs. In contrast to simulation (like MCMC), this analysis yields exact results. Our technique is based on weakest precondition reasoning. We will explain the foundations of this approach, present some proof rules to reason about probabilistic while-loops, and discuss how the analysis can be automated \u2014 either fully or with the help of invariants."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"/blog/2025/06/10/caesar-at-ssft-25#materials",children:"material is available online"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsx)(t.p,{children:"The slides and exercise sheets for the lectures and labs are available online:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"pathname:///assets/ssft25/SSFT25-lectures.pdf",children:"Lecture Slides: Deductive Verification of Probabilistic Programs"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"pathname:///assets/ssft25/SSFT25-labs.pdf",children:"Exercises for the two lab sessions"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Solutions are available on request (email us at ",(0,s.jsx)(t.a,{href:"mailto:phisch@cs.rwth-aachen.de",children:"phisch@cs.rwth-aachen.de"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://ssft-sri.github.io/materials/zoom.txt",children:"Video recordings are also available online"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Further recommended materials were:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://doi.org/10.1017/9781108770750.007",children:"Foundations of Probabilistic Programming Ch. 6: Expected Runtime Analysis by Program Verification"})}),"\n",(0,s.jsxs)(t.li,{children:["Annabelle McIver, Carroll Morgan, Benjamin Lucien Kaminski, Joost-Pieter Katoen: ",(0,s.jsx)(t.a,{href:"https://doi.org/10.1145/3158121",children:"A new proof rule for almost-sure termination"}),". Proc. ACM Program. Lang. 2(POPL): 33:1-33:28 (2018)"]}),"\n",(0,s.jsxs)(t.li,{children:["Joost-Pieter Katoen, Friedrich Gretz, Nils Jansen, Benjamin Lucien Kaminski, Federico Olmedo: ",(0,s.jsx)(t.a,{href:"https://doi.org/10.1007/978-3-319-23506-6_4",children:"Understanding Probabilistic Programs"}),". Correct System Design 2015: 15-32"]}),"\n",(0,s.jsxs)(t.li,{children:["Joost-Pieter Katoen: ",(0,s.jsx)(t.a,{href:"https://www.youtube.com/watch?v=I3sOp_mbs8k",children:"Deductive Verification of Probabilistic Programs: From Theory to Automation"}),". Tutorial at ETAPS 2023."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>n,x:()=>o});var a=r(6540);const s={},i=a.createContext(s);function n(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);