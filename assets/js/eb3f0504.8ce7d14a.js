"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[9152],{8728:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"proof-rules/unrolling","title":"Loop Unrolling","description":"Loop unrolling and bounded model checking.","source":"@site/docs/proof-rules/unrolling.md","sourceDirName":"proof-rules","slug":"/proof-rules/unrolling","permalink":"/docs/proof-rules/unrolling","draft":false,"unlisted":false,"editUrl":"https://github.com/moves-rwth/caesar/tree/main/website/docs/proof-rules/unrolling.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Loop Unrolling","description":"Loop unrolling and bounded model checking.","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Induction and k-Induction","permalink":"/docs/proof-rules/induction"},"next":{"title":"\u03c9-Invariants","permalink":"/docs/proof-rules/omega-invariants"}}');var t=o(4848),s=o(8453);const r={title:"Loop Unrolling",description:"Loop unrolling and bounded model checking.",sidebar_position:3},c="Loop Unrolling and Bounded Model Checking",l={},a=[{value:"Usage",id:"usage",level:2},{value:"Verification Example",id:"verification-example",level:2},{value:"Refutation (Bounded Model Checking)",id:"bounded-model-checking",level:2},{value:"Soundness",id:"soundness",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"loop-unrolling-and-bounded-model-checking",children:"Loop Unrolling and Bounded Model Checking"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Loop unrolling"})," (also known as ",(0,t.jsx)(n.em,{children:"fixpoint iteration"})," or ",(0,t.jsx)(n.em,{children:"Kleene iteration"}),") replaces a ",(0,t.jsx)(n.code,{children:"while"})," loop by a fixed number of iterations ",(0,t.jsx)(n.code,{children:"k"})," and a ",(0,t.jsx)(n.em,{children:"terminator"})," expectation to be used if more than ",(0,t.jsx)(n.code,{children:"k"})," iterations run.\nThis simple proof rule does not require invariants, just a choice of how many loop iterations to be done.\nThe necessary terminator is usually clear from the context."]}),"\n",(0,t.jsxs)(n.p,{children:["Just like all others of Caesar's proof rules, loop unrolling can be used as a proof rule for verification.\nBut it also often used in ",(0,t.jsx)(n.em,{children:"bounded model checking"})," not to ",(0,t.jsx)(n.em,{children:"prove"}),", but to ",(0,t.jsx)(n.em,{children:"refute"})," specifications.\nSee the ",(0,t.jsxs)(n.a,{href:"#bounded-model-checking",children:[(0,t.jsx)(n.em,{children:"Bounded Model Checking"})," section"]})," below for details on the use of this proof rule for refutations."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Terminology ",(0,t.jsx)(n.em,{children:'"Bounded Model Checking"'})]}),(0,t.jsxs)(n.p,{children:["The term ",(0,t.jsx)(n.em,{children:"bounded model checking"})," in this document refers to Caesar's proof rule of unrolling as applied to refutations.\nIt supports all of the symbolic reasoning that you know from Caesar."]}),(0,t.jsxs)(n.p,{children:["But there is also ",(0,t.jsx)(n.em,{children:"(probabilistic) model checking"}),", which usually refers to tools and techniques that construct a (finite) state space explicitly and then analyze the program.\nThese allow both proofs and verification.\nAll of this is unfortunately standard terminology."]})]}),"\n",(0,t.jsx)(n.admonition,{title:"Using Probabilistic Model Checkers Instead",type:"note",children:(0,t.jsxs)(n.p,{children:["Sometimes, using a ",(0,t.jsx)(n.em,{children:"probabilistic model checker"})," such as ",(0,t.jsx)(n.a,{href:"https://www.stormchecker.org/",children:"Storm"})," is an alternative to Caesar's loop unrolling.\n",(0,t.jsx)(n.a,{href:"/docs/model-checking",children:"Caesar's support for model checking"})," can translate (executable) HeyVL programs to the ",(0,t.jsx)(n.a,{href:"https://jani-spec.org/",children:"JANI format"}),", which can be used as an input to Storm.\nThis may be an option if you do not need the power of Caesar's deductive verification, but want to build the state space explicitly."]})}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"while"})," loop is annotated by the ",(0,t.jsx)(n.code,{children:"@unroll(k, terminator)"})," annotation where ",(0,t.jsx)(n.code,{children:"k"})," is a number literal and ",(0,t.jsx)(n.code,{children:"terminator"})," is an expression of type ",(0,t.jsx)(n.code,{children:"EUReal"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"terminator"})," should be the initial value of the fixpoint iteration.\nThus, one chooses the ",(0,t.jsx)(n.code,{children:"terminator"})," to encode the loop unrolling such that it either"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["over-approximates greatest fixed-point semantics:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["commonly ",(0,t.jsx)(n.code,{children:"1"})," for the one-bounded wlp semantics,"]}),"\n",(0,t.jsxs)(n.li,{children:["or ",(0,t.jsx)(n.code,{children:"\\infty"})," for the unbounded expectation-based semantics."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["under-approximates least fixed-point semantics:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["commonly ",(0,t.jsx)(n.code,{children:"0"})," for expectation-based semantics (wp, ert)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["See the ",(0,t.jsx)(n.a,{href:"#soundness",children:"section on soundness"})," below."]}),"\n",(0,t.jsx)(n.h2,{id:"verification-example",children:"Verification Example"}),"\n",(0,t.jsxs)(n.p,{children:["In the simple example below, we show a lower bound of ",(0,t.jsx)(n.code,{children:"0.75"})," on the probability value of termination in at most 3 iterations of the loop.\nWe want to encode a loop with least fixed-point semantics, so we use ",(0,t.jsx)(n.code,{children:"0"})," as our ",(0,t.jsx)(n.code,{children:"terminator"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"@wp proc geo1_unroll() -> (c: UInt)\n    pre 0.75\n    post 1\n{\n    c = 0\n    var cont: Bool = true\n    @unroll(3, 0) // k = 3, terminator = 0\n    while cont {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsxs)(n.a,{href:"/docs/proof-rules/calculi",children:[(0,t.jsx)(n.code,{children:"@wp"})," annotation"]})," annotation adds a sanity check from Caesar that we correctly reason about ",(0,t.jsx)(n.em,{children:"weakest pre-expectations"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Internally, the loop is replaced by its unfolding, with a ",(0,t.jsx)(n.code,{children:"assert 0; assume 0"})," at the end of the ",(0,t.jsx)(n.code,{children:"k = 3"})," loop iterations."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"if cont {\n    ... body ...\n    if cont {\n        ... body ...\n        if cont {\n            ... body ...\n            assert 0; assume 0 // terminator = 0\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["There is a ",(0,t.jsx)(n.code,{children:"0.25"})," chance of reaching the ",(0,t.jsx)(n.code,{children:"assert 0"}),", so we can at most prove a lower bound of ",(0,t.jsx)(n.code,{children:"0.75"})," with ",(0,t.jsx)(n.code,{children:"k = 3"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Notice that ",(0,t.jsx)(n.code,{children:"k = 3"})," generates three ",(0,t.jsx)(n.code,{children:"if cont { ... }"})," statements, but that the last body has essentially constant zero semantics due to the ",(0,t.jsx)(n.code,{children:"assert 0"})," at the end.\nSo we get probability mass from the first ",(0,t.jsx)(n.em,{children:"two"})," iterations only (",(0,t.jsx)(n.code,{children:"0.5 + 0.25"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"bounded-model-checking",children:"Refutation (Bounded Model Checking)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Bounded model checking"})," (BMC) is what we usually call using loop unrolling when we ",(0,t.jsx)(n.em,{children:"refute"})," a specification with it.\nThe idea is that if a specification does not hold e.g. for 12 loop steps, then we can guarantee that it still will not hold for more potential loop steps."]}),"\n",(0,t.jsx)(n.admonition,{type:"danger",children:(0,t.jsx)(n.p,{children:"Bounded model checking is a technique for refuting verification (if there is a counter-example, it is valid for the original program) but can make successful verification unsound (if the program verifies, we know nothing)."})}),"\n",(0,t.jsxs)(n.p,{children:["In the following example, we use loop unrolling to ",(0,t.jsx)(n.em,{children:"under-approximate"})," least fixed-point semantics in an ",(0,t.jsx)(n.em,{children:"upper-bound context"})," (",(0,t.jsx)(n.code,{children:"coproc"}),").\nBecause we want to approximate least fixpoint semantics, we use ",(0,t.jsx)(n.code,{children:"0"})," as our ",(0,t.jsx)(n.code,{children:"terminator"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Because loop unrolling ",(0,t.jsx)(n.em,{children:"under-approximates"})," the least fixed-point, we know that if verification of an ",(0,t.jsx)(n.em,{children:"upper bound fails"}),", then we have refuted the upper bound.\nOn the other hand, if verification succeeds, we cannot conclude that the specification holds."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-heyvl",children:"coproc geo1_bmc(init_c: UInt) -> (c: UInt)\n    pre init_c + 0.99\n    post c\n{\n    c = init_c\n    var cont: Bool = true\n    @unroll(12, 0) // k = 12, terminator = 0\n    while cont {\n        var prob_choice: Bool = flip(0.5)\n        if prob_choice { cont = false } else { c = c + 1 }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Trying to verify ",(0,t.jsx)(n.code,{children:"geo1_unroll"})," will yield a counter-example to verification.\nBecause this is loop unrolling, it is a ",(0,t.jsx)(n.em,{children:"true counter-example"})," to ",(0,t.jsx)(n.code,{children:"init_c + 0.99"})," being an upper bound.\nOn the other hand, if you change ",(0,t.jsx)(n.code,{children:"k = 11"}),", then the program verifies.\nBut this tells you nothing about the actual program semantics."]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Remember that correctness of encoding BMC here depends on the fact that we encoded a sound under-approximation on a least fixpoint in a ",(0,t.jsx)(n.code,{children:"coproc"}),".\nIf you over-approximate in this program, e.g. using additional ",(0,t.jsx)(n.code,{children:"coassert"})," statements or ",(0,t.jsx)(n.code,{children:"coproc"})," calls, then you might get spurious counterexamples again.\nThen BMC would be useless!"]})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@unroll"})," annotation only provides a sound under-approximation for the ",(0,t.jsx)(n.code,{children:"wp"})," and ",(0,t.jsx)(n.code,{children:"ert"})," calculi and only a sound over-approximation for ",(0,t.jsx)(n.code,{children:"wlp"})," (cf. ",(0,t.jsx)(n.a,{href:"/docs/proof-rules/calculi",children:"calculus annotations"}),").\nThe calculus annotations check ",(0,t.jsx)(n.em,{children:"soundness"})," in the limited sense that verification implies that the specification holds for the original program.\nTherefore, the calculus annotations would ",(0,t.jsx)(n.em,{children:"not allow"})," the above combination of ",(0,t.jsx)(n.code,{children:"coproc"})," with the ",(0,t.jsx)(n.code,{children:"@wp"})," annotation."]}),(0,t.jsxs)(n.p,{children:["However, here it is still correct to ",(0,t.jsx)(n.em,{children:"under-approximate"})," the ",(0,t.jsx)(n.code,{children:"wp"})," and then conclude from a counter-example of an ",(0,t.jsx)(n.em,{children:"upper bound"})," (",(0,t.jsx)(n.code,{children:"coproc"}),") that the upper bound is not valid for the original program!\nBut calculus annotations do not support the task of checking for sound ",(0,t.jsx)(n.em,{children:"refutations"})," yet."]})]}),"\n",(0,t.jsx)(n.h2,{id:"soundness",children:"Soundness"}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"https://link.springer.com/chapter/10.1007/978-3-030-81688-9_25",children:(0,t.jsx)(n.em,{children:"Latticed k-Induction with an Application to Probabilistic Programs"})})," (CAV 2021) for more information on the theory of ",(0,t.jsx)(n.em,{children:"bounded model checking"})," on probabilistic programs."]}),"\n",(0,t.jsxs)(n.p,{children:["One needs to be very careful in choosing the ",(0,t.jsx)(n.code,{children:"terminator"})," such that ",(0,t.jsx)(n.code,{children:"@unroll"})," actually approximates the correct fixed-point corresponding to the desired semantics (see ",(0,t.jsx)(n.a,{href:"#usage",children:"Usage"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Notice that you ",(0,t.jsx)(n.strong,{children:"cannot"})," ",(0,t.jsx)(n.em,{children:"under-approximate a greatest fixed-point semantics"})," or ",(0,t.jsx)(n.em,{children:"over-approximate a least fixed-point semantics"})," with loop unrolling, in contrast to the other proof rules such as ",(0,t.jsx)(n.a,{href:"/docs/proof-rules/induction",children:"induction"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>c});var i=o(6540);const t={},s=i.createContext(t);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);