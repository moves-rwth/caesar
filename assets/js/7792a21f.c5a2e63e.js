"use strict";(self.webpackChunkcaesar_website=self.webpackChunkcaesar_website||[]).push([[1220],{6905:(e,i,s)=>{s.r(i),s.d(i,{default:()=>o});s(6540);var r=s(1330),a=s(8774),t=s(4848);function o(){return(0,t.jsx)(r.A,{title:"About Caesar",description:"About Caesar",children:(0,t.jsxs)("div",{style:{display:"grid",maxWidth:"800px",margin:"2em auto",textAlign:"justify"},children:[(0,t.jsx)("h1",{children:"About Caesar"}),(0,t.jsx)("p",{children:"Caesar is a deductive verification infrastructure specifically designed for probabilistic programs. That means it is a tool to provide formal guarantees for programs that incorporate probabilistic behaviours, such as drawing random numbers or making random choices."}),(0,t.jsxs)("p",{children:["Probabilistic programs can be found in randomized algorithms, communication protocols, machine learning models, and many other domains. When designing or analyzing such programs, many questions can be formulated with respect to some kind of ",(0,t.jsx)("em",{children:"expected value"}),", such as the probability of reaching a certain state, the expected number of steps until a certain event occurs, or the expected value of some variable at the end of the program. We support the use of different proof rules, from areas such as martingale analysis or domain theory, thus enabling reasoning about programs with infinite state spaces and unbounded loops."]}),(0,t.jsxs)("p",{children:["Caesar aims to be a ",(0,t.jsx)("em",{children:"verification infrastructure"})," that combines many different techniques to formally reason about such expected values. We want to provide a tool that automates the verification process as much as possible, while still allowing the user to guide the verification process and provide additional information when needed. This differs from ",(0,t.jsx)("em",{children:"probabilistic model checkers"})," such as ",(0,t.jsx)(a.A,{to:"https://www.stormchecker.org/",children:"Storm"})," or ",(0,t.jsx)(a.A,{to:"https://www.prismmodelchecker.org/",children:"PRISM"}),', which are more "push-button" approaches that require less user interaction but struggle with e.g. infinite state spaces.']}),(0,t.jsxs)("p",{children:["Caesar is an open-source project from ",(0,t.jsx)(a.A,{to:"https://moves.rwth-aachen.de/",children:"RWTH Aachen University (MOVES group)"}),", ",(0,t.jsx)(a.A,{to:"https://quave.cs.uni-saarland.de/",children:"Saarland University (QUAVE group)"}),", ",(0,t.jsx)(a.A,{to:"https://www.compute.dtu.dk/english/research/research-sections/software-systems-engineering",children:"Denmark Technical University (SSE section)"}),", and ",(0,t.jsx)(a.A,{to:"http://pplv.cs.ucl.ac.uk/welcome/",children:"University College London (PPLV group)"}),". The ",(0,t.jsx)(a.A,{to:"https://www.github.com/moves-rwth/caesar",children:"source code is available on GitHub"}),'. The name "Caesar" comes from "veni, vidi, vc", where we let "vc" stand for "verification conditions".']}),(0,t.jsx)("h2",{children:"Main Features"}),(0,t.jsxs)("ul",{children:[(0,t.jsx)("li",{children:"Verification of expected values in probabilistic programs"}),(0,t.jsx)("li",{children:"Support for infinite state spaces, unbounded loops, and recursion"}),(0,t.jsx)("li",{children:"Support for different proof rules, such as from martingale analysis or domain theory"}),(0,t.jsx)("li",{children:"Integration with SMT solvers and probabilistic model checkers"}),(0,t.jsx)("li",{children:"Program slicing for error localization and hints"}),(0,t.jsx)("li",{children:"Integration with Visual Studio Code"})]}),(0,t.jsx)("h2",{children:"Key Components"}),(0,t.jsxs)("h3",{children:["The Quantitative Intermediate Verification Language ",(0,t.jsx)("em",{children:"HeyVL"})]}),(0,t.jsxs)("p",{children:["The architecture of Caesar is inspired by modern program verifiers that use an ",(0,t.jsx)("em",{children:"intermediate verification language"})," (IVL) to encode a program, its specification, and proof rules into a common representation. Our ",(0,t.jsx)("em",{children:"quantitative"})," IVL is called ",(0,t.jsx)("em",{children:(0,t.jsx)(a.A,{to:"/docs/heyvl/",children:"HeyVL"})}),". HeyVL generalizes classical IVLs to the quantitative setting through ",(0,t.jsx)("em",{children:"HeyLo"}),", our new quantitative logic developed for Caesar. The names come from ",(0,t.jsx)(a.A,{to:"https://en.wikipedia.org/wiki/Heyting_algebra",children:"Heyting algebras"}),", which underlie the logic."]}),(0,t.jsxs)("p",{children:["In Caesar, HeyVL also has high-level constructs such as loops or procedure calls, but these are all encoded into a smaller core language. This core language and many encodings are described in our ",(0,t.jsxs)(a.A,{to:"docs/publications#oopsla-23",children:["OOPSLA 2023 publication ",(0,t.jsx)("em",{children:'"A Deductive Verification Infrastructure for Probabilistic Programs"'})]}),"."]}),(0,t.jsx)("h3",{children:"Backends: SMT Solving and Probabilistic Model Checking"}),(0,t.jsxs)("p",{children:["Caesar uses the ",(0,t.jsx)(a.A,{to:"https://www.microsoft.com/en-us/research/project/z3-3/",children:"Z3 SMT solver"})," to reason about HeyVL programs. This allows Caesar to use symbolic reasoning to prove properties of probabilistic programs, enabling reasoning about infinite state spaces and unbounded loops. It is also possible to use other SMT solvers (",(0,t.jsx)(a.A,{to:"docs/caesar/",children:"by emitting SMT-LIB"}),")."]}),(0,t.jsxs)("p",{children:["In addition, Caesar has ",(0,t.jsx)(a.A,{to:"/docs/model-checking",children:"a model checking backend"})," that emits files in the ",(0,t.jsx)(a.A,{to:"https://jani-spec.org/",children:"JANI format"}),', a JSON-based interchange format for probabilistic models. This is possible for an "executable" subset of HeyVL programs that can be translated into JANI models. The result can be fed into probabilistic model checkers such as ',(0,t.jsx)(a.A,{to:"https://www.stormchecker.org/",children:"Storm"}),"."]}),(0,t.jsx)("h3",{children:"Slicing for Error Localization and Hints"}),(0,t.jsxs)("p",{children:["Caesar includes a ",(0,t.jsxs)(a.A,{to:"docs/caesar/slicing",children:[(0,t.jsx)("em",{children:"program slicing"})," engine called ",(0,t.jsx)("em",{children:"Brutus"})]})," (get it?) that reduces HeyVL programs with respect to certain properties. Slicing is Caesar's theoretical and practical foundation for error localization and hints. For example, by removing assertions from the program, we can find out the remaining assertions which must cause a verification failure."]}),(0,t.jsx)("h3",{children:"Visual Studio Code Integration"}),(0,t.jsxs)("p",{children:["We value usability and user-friendliness highly and want to make Caesar as easy to use as possible. It is our belief that UX is a key factor in making formal verification succeed in practice. This is why we put a lot of effort into ",(0,t.jsx)(a.A,{to:"/docs/caesar/vscode-and-lsp/",children:"integrating Caesar with Visual Studio Code"})," with our ",(0,t.jsx)(a.A,{to:"https://marketplace.visualstudio.com/items?itemName=rwth-moves.caesar",children:"Caesar for VSCode extension"}),"."]}),(0,t.jsx)("h2",{children:"Disclaimer: (Un)Related Work"}),(0,t.jsxs)("p",{children:["Caesar should not be confused with the set of tools in the ",(0,t.jsx)(a.A,{to:"https://cadp.inria.fr/",children:"CADP toolbox"})," by INRIA, which includes tools like the CAESAR or CAESAR.ADT compilers, or the OPEN/CAESAR software architecture."]})]})})}}}]);