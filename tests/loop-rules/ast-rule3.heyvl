// RUN: @caesar @file
// Mostly auto-generated by pgcl2heyvl from ast-rule3.pgcl (Automatic generation of domains are currently not supported.)
//
// HeyVL file to show that C is almost-surely terminating
// using AST rule by McIver et al. (2018) with
// invariant = true, variant = harmonic(x), probability function p(v) = (1/3), decrease function d(v) = 1/x' if v > 0 where harmonic(x'-1) < v <= harmonic(x') else 1
// for the pGCL program C:
//
//     nat x;
//     while (0 < x) {
//         {
//             x := x - 1;
//         } [x / ((2 * x) + 1)] {
//             x := x + 1;
//         }
//     }
//
// Note that we do not check if the probability and decrease function are antitone! (Which is present in other auto-generated encodings)

domain Functions {
    func harmonic(n: UInt): UReal

    axiom harmonic_base harmonic(0) == 0
    axiom harmonic_step forall n: UInt @trigger(harmonic(n)). harmonic(n + 1) == 1/(n+1) + harmonic(n)

    func d(v: UReal): UReal

    axiom d_def forall n: UInt. (n > 0) ==> (d(harmonic(n)) == 1/n)
    axiom d_zero d(0) == 1
}



// [I] <= \Phi_{[I]}([I])
proc I_wp_subinvariant(init_x: UInt) -> (x: UInt)
    pre [true]
    post [true]
{
    var prob_choice: Bool
    x = init_x
    if 0 < x {
        prob_choice = flip(x / ((2 * x) + 1))
        if prob_choice {
            x = x - 1
        } else {
            x = x + 1
        }
    } else {}
}

// !G iff V = 0
proc termination_condition(x: UInt) -> ()
{
    assert ?(!(0 < x) == (harmonic(x) == 0))
}

// \Phi_{V}(V) <= V
coproc V_wp_superinvariant(init_x: UInt) -> (x: UInt)
    pre harmonic(init_x)
    post harmonic(x)
{
    var prob_choice: Bool
    x = init_x
    if 0 < x {
        prob_choice = flip(x / ((2 * x) + 1))
        if prob_choice {
            x = x - 1
        } else {
            x = x + 1
        }
    } else {}
}

// [I] * [G] * (p o V) <= \s. wp[P]([V < V(s) - d(V(s))])(s)
proc progress_condition(init_x: UInt) -> (x: UInt)
    pre [true] * ([0 < init_x] * (1/3))
    post [harmonic(x) <= (harmonic(init_x) - d(harmonic(init_x)))]
{
    var prob_choice: Bool
    x = init_x
    prob_choice = flip(x / ((2 * x) + 1))
    if prob_choice {
        x = x - 1
    } else {
        x = x + 1
    }
}
