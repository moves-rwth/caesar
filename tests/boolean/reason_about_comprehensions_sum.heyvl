// RUN: @caesar verify --function-encoding variable-fuel --quantifier-instantiation e-matching @file

// Sum examples from the paper "Reasoning about Comprehensions with First-Order SMT Solvers" (Section 4.1)

domain Sum {

    // Induction below axiom
    func elementSum(lo: UInt, hi: UInt, a: []Int): Int = ite(lo < hi, select(a, lo) + elementSum(lo + 1, hi, a), 0)

    axiom induction_above forall lo: UInt, hi: UInt, a: []Int @trigger(elementSum(lo, hi, a)) .
        elementSum(lo, hi, a) == ite(lo < hi, select(a, hi - 1) + elementSum(lo, hi - 1, a), 0)

    // One of the above axiom can also be created from the other using the split_range axiom,
    // This requires a fuel value greater than 1

    // Omitting triggers here is detrimental to the performance
    /* axiom split_range forall lo: UInt, mid: UInt, hi: UInt, a: []Int @trigger(elementSum(lo, mid, a), elementSum(mid, hi, a)) @trigger(elementSum(lo, mid, a), elementSum(lo, hi, a)) @trigger(elementSum(lo, hi, a), elementSum(mid, hi, a)) .
        (lo <= mid &&  mid <= hi) ==> (elementSum(lo, mid, a) + elementSum(mid, hi, a) == elementSum(lo, hi, a)) */

}

proc Sum1(a: []Int) -> (s: Int)
    post ?(s == elementSum(0, len(a), a))
{
    s = 0;

    var n: UInt = 0;
    @invariant(?(n <= len(a) && s == elementSum(0, n, a)))
    while (n < len(a)) {
        s = s + select(a, n);
        n = n + 1;
    }
}

proc Sum2(a: []Int) -> (s: Int)
    post ?(s == elementSum(0, len(a), a))
{
    s = 0;

    var n: UInt = len(a);
    @invariant(?(n <= len(a) && s == elementSum(n, len(a), a)))
    while (1 <= n) {
        s = s + select(a, n - 1);
        n = n - 1;
    }
}