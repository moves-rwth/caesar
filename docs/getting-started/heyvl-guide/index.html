<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-getting-started/heyvl-guide" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Guide to HeyVL | Caesar</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.caesarverifier.org/img/social-card.png"><meta data-rh="true" name="twitter:image" content="https://www.caesarverifier.org/img/social-card.png"><meta data-rh="true" property="og:url" content="https://www.caesarverifier.org/docs/getting-started/heyvl-guide"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Guide to HeyVL | Caesar"><meta data-rh="true" name="description" content="A guide to understanding and verifying HeyVL."><meta data-rh="true" property="og:description" content="A guide to understanding and verifying HeyVL."><link data-rh="true" rel="icon" href="/img/laurel.svg"><link data-rh="true" rel="canonical" href="https://www.caesarverifier.org/docs/getting-started/heyvl-guide"><link data-rh="true" rel="alternate" href="https://www.caesarverifier.org/docs/getting-started/heyvl-guide" hreflang="en"><link data-rh="true" rel="alternate" href="https://www.caesarverifier.org/docs/getting-started/heyvl-guide" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Caesar RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Caesar Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-73RDXJSM5X"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-73RDXJSM5X",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.b070e9d8.css">
<link rel="preload" href="/assets/js/runtime~main.639b0ec0.js" as="script">
<link rel="preload" href="/assets/js/main.74b8c474.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/laurel.svg" alt="Caesar Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/laurel.svg" alt="Caesar Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Caesar</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/getting-started">Getting Started</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/blog">News</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/moves-rwth/caesar" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a class="navbar__item navbar__link" href="/docs/publications">Publications</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/getting-started/">Getting Started</a><button aria-label="Toggle the collapsible sidebar category &#x27;Getting Started&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/getting-started/installation">Installing Caesar</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/getting-started/heyvl-guide">Guide to HeyVL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/getting-started/zoo-of-heyvl-examples">A Zoo of HeyVL Examples</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/heyvl/">HeyVL</a><button aria-label="Toggle the collapsible sidebar category &#x27;HeyVL&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/stdlib/">Standard Library</a><button aria-label="Toggle the collapsible sidebar category &#x27;Standard Library&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/proof-rules/">Proof Rules</a><button aria-label="Toggle the collapsible sidebar category &#x27;Proof Rules&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/caesar/">The Caesar Tool</a><button aria-label="Toggle the collapsible sidebar category &#x27;The Caesar Tool&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/model-checking">Model Checking</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/devguide">Development Guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/publications">Publications</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/OOPSLA_AEC">OOPSLA &#x27;23 Artifact Evaluation Guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/pgcl">pGCL Frontend</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/getting-started/"><span itemprop="name">Getting Started</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Guide to HeyVL</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Guide to HeyVL</h1><p>After <a href="/docs/getting-started/installation">installing Caesar</a>, we can start to use HeyVL with Caesar.
In this guide, we&#x27;ll go through the basics of HeyVL and how verification problems can be encoded in it.
We&#x27;ll use the <em>lossy list</em> example from our <a href="/">home page</a> to understand HeyVL.
On the next page, we present <a href="/docs/getting-started/zoo-of-heyvl-examples">a collection of HeyVL examples</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="contents-of-this-guide">Contents of this guide<a href="#contents-of-this-guide" class="hash-link" aria-label="Direct link to Contents of this guide" title="Direct link to Contents of this guide">​</a></h4><div class="tableOfContentsInline_prmo"><ul class="table-of-contents"><li><a href="#what-are-heyvl-and-caesar">What are HeyVL and Caesar?</a><ul><li><a href="#architecture">Architecture</a></li><li><a href="#features">Features</a></li></ul></li><li><a href="#verifying-our-first-program-lossy-list-traversal">Verifying Our First Program: Lossy List Traversal</a><ul><li><a href="#the-probabilistic-program-itself">The Probabilistic Program Itself</a></li><li><a href="#user-defined-datatypes-and-functions">User-Defined Datatypes and Functions</a></li><li><a href="#specifications-and-invariants">Specifications and Invariants</a></li><li><a href="#full-example">Running the Complete Example</a></li><li><a href="#upper-bounds">Reasoning About Upper Bounds (Coprocedures)</a></li></ul></li><li><a href="#verification-statements">Verification Statements</a><ul><li><a href="#boolean-verification-statements">Boolean Verification Statements</a></li><li><a href="#expectation-based-reasoning">Expectation-Based Reasoning</a></li><li><a href="#assumptions-and-assertions">Assumptions and Assertions</a></li><li><a href="#havoc">Havoc</a></li><li><a href="#nondeterministic-choice">Nondeterministic Choice</a></li><li><a href="#rewards">Rewards</a></li></ul></li></ul></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-are-heyvl-and-caesar">What are HeyVL and Caesar?<a href="#what-are-heyvl-and-caesar" class="hash-link" aria-label="Direct link to What are HeyVL and Caesar?" title="Direct link to What are HeyVL and Caesar?">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="architecture">Architecture<a href="#architecture" class="hash-link" aria-label="Direct link to Architecture" title="Direct link to Architecture">​</a></h3><figure style="max-width:400px;float:right;width:100%;border:1px solid gray;padding:1em;border-radius:5px"><h3 style="text-align:center">Architecture of Caesar</h3><img loading="lazy" src="/img/architecture-oopsla23.svg" class="img_ev3q"></figure><p>On the right, you can see the architecture of Caesar.
Caesar is designed as a <em>deductive verification infrastructure</em> for probabilistic programs.</p><p>At the core is <em>HeyVL</em>, our <em>intermediate verification language</em> (IVL).
An IVL is used to encode a wide range of verification problems and verification techniques into a common language.
In contrast to normal programming languages, IVLs can feature statements such as <code>assert</code> and <code>assume</code>.
Intuitively, <code>assert</code> checks a condition and fails if it&#x27;s not true.
<code>assume</code> lets us make a logical assumption at arbitrary points in the program.
These can be used to encode proofs and proof rules into the IVL.
HeyVL is a <em>quantitative</em> IVL, meaning that its verification statements (<code>assert</code>, <code>assume</code>, <code>havoc</code>...) do not only reason about Boolean statements (<code>x = 3</code>), but rather about quantities such as expected values (<code>[x = 3] * 0.5</code>).</p><p>The <em>verification condition generator</em> (VC generator) takes a HeyVL program and converts it to <em>verification conditions</em>, which is a logical formula in our quantative logic <em>HeyLo</em>.
This formula specifies logically whether a HeyVL program verifies or not.
For example, <code>assume [x = 3]; assert 0.5</code> is converted to the HeyLo formula <code>[x = 3] → 0.5</code>.
We will explain what this means later in this guide (see the section on <a href="#verification-statements">verification statements</a>).
At the end, Caesar converts the HeyLo formula into a problem for an <em>SMT solver</em>; currently we use <a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener noreferrer">Z3</a>.
This allows us to check whether a program verifies <em>for all possible inputs</em>.
If verification fails, then the SMT solver can often return a counter-example, i.e. an input to the program so that the program does not verify.</p><p>Caesar supports a number of proof rules out of the box (see <a href="/docs/proof-rules/">proof rules documentation</a>).
For example, reasoning about <em>while loops</em> or recursion is done through proof rules.
By adding an annotation such as <a href="/docs/proof-rules/induction"><code>@invariant</code></a> to a while loop, you can instruct Caesar use the <em>Park induction</em> proof rule.
However, this will internally desugar into normal HeyVL code which means these proof rules are <em>not</em> magic built-ins, but just a convenience in Caesar.
Thus, you can add your own proof rules with Caesar by encoding them in HeyVL.
That is the advantage of using an intermediate verification language such as HeyVL.</p><div style="clear:both"></div><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>The language HeyVL and the basics of Caesar are formally described in our <a href="/docs/publications#oospla-23">OOPLSA &#x27;23 publication <em>&quot;A Deductive Verification Infrastructure for Probabilistic Programs&quot;</em></a> (<a href="https://arxiv.org/pdf/2309.07781.pdf" target="_blank" rel="noopener noreferrer">direct link to extended version pdf</a>).
There, you can find rock-solid formal foundations for HeyVL and details on how to prove that HeyVL programs are <em>correct</em>, i.e. actually encode the desired verification problems.
We highly recommend you take a look at it after reading this guide for a more rigorous treatment of HeyVL and Caesar.
Refer to our <a href="/docs/publications#oopsla-23">publications page</a> for more details.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="features">Features<a href="#features" class="hash-link" aria-label="Direct link to Features" title="Direct link to Features">​</a></h3><p>So, what can we do with HeyVL and Caesar right now?
Here&#x27;s an incomplete list of features:</p><ul><li>Prove correctness and find bugs in probabilistic programs.<ul><li>We have verified properties like lower and upper bounds on expected values, such as expected values on termination, expected runtimes, expected resource consumption, termination probabilities, and more.</li><li>Using proof rules like Park induction, k-induction, rules for positive almost-sure and almost-sure termination, or the optional stopping theorem.</li></ul></li><li>Use <em>HeyVL</em>, a <em>quantitative</em> intermediate verification language that<ul><li>has generalized quantitative verification statements <code>assume</code>, <code>assert</code>, <code>havoc</code>, and nondeterministic choice,</li><li>features dual <em>co</em>-versions of verification statements to reason about <em>upper bounds</em> of expected values (the non-<code>co</code> statements are used to reason about <em>lower bounds</em>),</li><li>and through these allows you to encode new proof rules and use Caesar as a verifier for them.</li></ul></li><li>Leverage the power of modern SMT solvers to logically reason about infinite-state probabilistic systems with infinitely many inputs and outputs, and unbounded loops and recursion.</li><li>Compositionally reason about programs, building bigger verified programs out of smaller verified parts using procedures.</li><li>Define your own data types and define new functions in HeyVL, with support for <em>uninterpreted</em> definitions, i.e. those defined by logical <em>axioms</em> and thus may not even have an executable definition.</li><li>Formally correct reasoning with theoretical guarantees. We do not use sampling algorithms such as <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo" target="_blank" rel="noopener noreferrer">MCMC</a>, but instead use logical reasoning about programs.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="verifying-our-first-program-lossy-list-traversal">Verifying Our First Program: Lossy List Traversal<a href="#verifying-our-first-program-lossy-list-traversal" class="hash-link" aria-label="Direct link to Verifying Our First Program: Lossy List Traversal" title="Direct link to Verifying Our First Program: Lossy List Traversal">​</a></h2><p>Let us now go through the lossy list example in detail and step-by-step.
The <a href="#full-example">full example can be found below</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-probabilistic-program-itself">The Probabilistic Program Itself<a href="#the-probabilistic-program-itself" class="hash-link" aria-label="Direct link to The Probabilistic Program Itself" title="Direct link to The Probabilistic Program Itself">​</a></h3><p>Let us start with the probabilistic program itself, without any HeyVL annotations.
<code>lossy_list</code> is a procedure that takes an input <code>init_L</code> of type <code>List</code> and returns an output list <code>l</code>.
<code>List</code> is a user-defined type <a href="#user-defined-datatypes-and-functions">which we define below</a>.</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">proc</span><span class="token plain"> lossy_list(init_l: List) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> (l: List)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> init_l</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">while</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">var</span><span class="token plain"> prob_choice: </span><span class="token builtin" style="color:rgb(72, 118, 214)">Bool</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> flip(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token plain">)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">if</span><span class="token plain"> prob_choice </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> pop(l)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">assert</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token boolean" style="color:rgb(188, 84, 84)">false</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The program is supposed to model a list traversal with a (rather alarming) 50% probability of memory faults during the traversal.
For this guide, we want to prove a lower bound to the probability of a successful traversal.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="what-does-the-program-do">What does the program do?<a href="#what-does-the-program-do" class="hash-link" aria-label="Direct link to What does the program do?" title="Direct link to What does the program do?">​</a></h4><ol><li><p>We initialize the output <code>l</code> to the input.
Note that it&#x27;s forbidden in HeyVL to modify input variables.</p></li><li><p>The main part of the code is the <code>while</code> loop.
It runs as long as the list <code>l</code> is not zero.</p><ol><li><p>In the loop body, we have our <em>probabilistic statement</em>: The <code>flip(0.5)</code> expression does a coin flip and returns <code>true</code> or <code>false</code>, each with probability <code>0.5</code>.
The result is saved in a newly declared variable <code>prob_choice</code> using the <code>var</code> statement.
When we declare a new variable in HeyVL, we always need to specify the type.</p></li><li><p>If the coin flip resulted in <code>true</code>, then we remove the first element of the top of the list using <code>pop</code>.
The resulting list has a length that&#x27;s one smaller than before.</p></li><li><p>If the coin flip resulted in <code>false</code>, then we simulate a memory fault using <code>assert [false]</code>.</p></li><li><small>Note: In HeyVL, while loops always need invariant annotations. Therefore, this program is not yet valid HeyVL code. We&#x27;ll add the annotation <a href="#specifications">when we talk about specifications</a>.</small></li></ol></li><li><p>HeyVL does not have <code>return</code> statements. Every value to be returned by the procedure must be declared as an output variable in the procedure declaration. Here, the output variable <code>l</code> is automatically returned.</p></li></ol><p>There is more detailed documentation on HeyVL&#x27;s <a href="/docs/heyvl/procs">procedures</a> and <a href="/docs/heyvl/statements">statements</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="what-do-we-want-to-verify">What do we want to verify?<a href="#what-do-we-want-to-verify" class="hash-link" aria-label="Direct link to What do we want to verify?" title="Direct link to What do we want to verify?">​</a></h4><p>With Caesar, various properties of this program can be verified:</p><ul><li><strong>In this guide, we&#x27;ll only verify that he probability of a successful run without crashing is at least <code>0.5^len(init_l)</code>.</strong></li><li>We could verify probabilities of crashing at specific list lengths.</li><li>We could verify expected values of list lengths at crash time.</li><li>For the above, we can verify either <em>lower</em> or <em>upper bounds</em>.</li><li>The program is <em>certainly terminating</em>, i.e. each execution will always terminate in a finite number of steps.<ul><li>There are programs that only terminate with probability one, but may have a zero probability of not terminating. We call these programs <em>almost-surely terminating</em> (<em>AST</em> for short).</li><li>There are programs which terminate with probability one, but do not have a finite expected runtime. Such programs are almost-surely terminating, but not <em>positively almost-surely terminating</em> (<em>PAST</em> for short).</li></ul></li><li>... and many more.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="user-defined-datatypes-and-functions">User-Defined Datatypes and Functions<a href="#user-defined-datatypes-and-functions" class="hash-link" aria-label="Direct link to User-Defined Datatypes and Functions" title="Direct link to User-Defined Datatypes and Functions">​</a></h3><p>Our probbabilistic program above is incomplete: it&#x27;s still missing a specification and a loop invariant annotation.
In addition, the <code>List</code> type and the <code>exp</code> function need to be defined.
They are not built-in into HeyVL, but must be <em>axiomatized</em> using user-defined domains and functions.</p><p>How this works is that domains and functions are defined <em>uninterpreted</em>, which means that they do not necessarily need to have a complete executable definition associated with them.
Domains are simply new types which functions can map from and into.
Functions simply have input and output types.</p><p>Then, <em>axioms</em> define the knowledge that Caesar (and the underlying SMT solver) will receive about these uninterpreted domains and functions.
For the purpose of verification, we check all possible definitions which satisfy these axioms and ignore those that do not satisfy them.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-list-type">The List Type<a href="#the-list-type" class="hash-link" aria-label="Direct link to The List Type" title="Direct link to The List Type">​</a></h4><p>Let&#x27;s declare our list type, using the <a href="/docs/stdlib/numbers#uint">built-in <code>UInt</code> type</a> for nonnegative integers.</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">domain</span><span class="token plain"> List </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> len(l: List): </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> pop(l: List): List</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> list_pop </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> l: List. len(pop(l)) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You will notice that we do not declare what a list consists or what size the data type should have.
We simply declare a domain <code>List</code> and have two uninterpreted functions <code>len</code> and <code>pop</code> operating on this type.
They also don&#x27;t have definitions, but only the axiom <code>list_pop</code> that says the length will decrease by one if we run <code>pop</code> on a list <code>l</code>.</p><p>These uninterpreted definitions are part of the magic of deductive verification using SMT solving that Caesar does.
We can simply define new types and functions <em>logically</em> via a (possibly partial) specification and verify with those.
This makes Caesar very extensible: new definitions do not need to be baked into Caesar itself, but can be defined by the user.
This makes axioms also extremely dangerous. Consider <code>axiom my_wrong_axiom false</code>.
Because <code>false</code> is never true for any interpretation, verification with this axiom will always succeed!</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-exponential-function">The Exponential Function<a href="#the-exponential-function" class="hash-link" aria-label="Direct link to The Exponential Function" title="Direct link to The Exponential Function">​</a></h4><p>Remember that we want to prove a lower bound of <code>0.5^len(init_l)</code> for the probability of a run without crashing.
Exponential functions are also not included in Caesar, but it can also be easily added.</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">domain</span><span class="token plain"> Exponentials </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> exp(base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain">): </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> exp_base </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token plain">. exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain">) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> exp_step </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain">. exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain">) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> base </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We declare a domain <code>Exponentials</code>.
The new type <code>Exponentials</code> is not used, but all function definitions and axioms need a surrounding <code>domain</code>.
The function <code>exp</code> takes a base and an exponent of type <code>UReal</code> and <code>UInt</code>, respectively.
See the <a href="/docs/stdlib/numbers">number types docs</a> for more information.</p><p>There are two axioms for <code>exp</code>.
The first, <code>exp_base</code> specifies that <code>exp(base, 0) == 1</code> holds for all <code>base</code> values.
The second, <code>exp_step</code> specifies the successive cases, <code>exp(base, exponent + 1) == base * exp(base, exponent)</code>.</p><p>You might wonder why we specify the exponential function in this inductive way and not via the <a href="https://en.wikipedia.org/wiki/Characterizations_of_the_exponential_function" target="_blank" rel="noopener noreferrer">many other definitions of the exponential function that Wikipedia provides</a>.
After all, we are not restricted to inductively computable definitions and can use any logical specification we want, right?
The answer here is that those two axioms are precisely the ones needed to prove our specific property using our chosen proof rule of <a href="/docs/proof-rules/induction">Park induction</a>.
We&#x27;ll see this below.
In general, what axioms you need to provide for verification is often specific to the verification task at hand.</p><p>Refer to the <a href="/docs/heyvl/domains">documentation on domains and functions</a> for more information.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="specifications-and-invariants">Specifications and Invariants<a href="#specifications-and-invariants" class="hash-link" aria-label="Direct link to Specifications and Invariants" title="Direct link to Specifications and Invariants">​</a></h3><p>Now that we have provided all necessary definitions for the program, let us write the specification.
Remember that we want to verify that the probability of a successful run without crashing is at least <code>exp(0.5, len(init_l))</code>.
How do we specify such a property in HeyVL?</p><p>HeyVL uses <em>expectation-based reasoning</em>, which is a kind of deductive reasoning that talks about expected values of random variables.
We describe the full theoretical details in our <a href="/docs/publications#oopsla-23">OOPSLA &#x27;23 publication</a>.
For now though, we&#x27;ll provide some intuition.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="specifications">Specifications<a href="#specifications" class="hash-link" aria-label="Direct link to Specifications" title="Direct link to Specifications">​</a></h4><p>We extend our <code>lossy_list</code> declaration as follows with a <code>pre</code> and a <code>post</code> attribute:</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">proc</span><span class="token plain"> lossy_list(init_l: List) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> (l: List)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">pre</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token plain">len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">post</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token boolean" style="color:rgb(188, 84, 84)">true</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">...</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>What does this mean?
Expectation-based reasoning always works backwards through the program.
Accordingly, we start our interpretation with the <code>post</code>.
The procedure having the post <code>[true]</code> means that we are ultimately interested in reasoning about the <em>expected value of <code>[true]</code> at termination</em>.
The Iverson bracket notation <code>[b]</code> maps a Boolean expression <code>b</code> to <code>1</code> if <code>b</code> evaluates to <code>true</code> and to <code>0</code> otherwise.
Therefore, <code>[true]</code> is equivalent to <code>1</code>.
It follows that <code>post [true]</code> means we are interested simply in the probability of successful termination.</p><p>The pre <code>[len(init_l) == 1] * 0.5</code> is a bit more interesting.
It results in a <em>proof obligation</em> for Caesar: the verifier now needs to show that <em>the pre is always a lower bound to the expected value of the post</em>.
The pre evaluates to <code>0.5</code> in case the length of the list is exactly one and to zero otherwise.
Since the pre is checked as a lower bound (and expected values are nonnegative in HeyVL), Caesar in effect only checks that <code>0.5</code> is a lower bound for inputs with list length equal to one.</p><p>Of course, we can also change the pre so that Caesar has to check infinitely many inputs, e.g. by changing the pre to <code>[len(init_l) != 1] * exp(0.5, len(init_l))</code>.
Thanks to the magic of deductive reasoning and SMT solvers, this will also work instantly.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="invariants">Invariants and Other Proof Rules<a href="#invariants" class="hash-link" aria-label="Direct link to Invariants and Other Proof Rules" title="Direct link to Invariants and Other Proof Rules">​</a></h4><p>Verification of programs with loops might require reasoning about an unbounded, possibly infinite number of loop iterations.
In deductive verification, we reduce reasoning of programs with loops to HeyVL programs without loops.
This is done using various <em>proof rules</em>.</p><p>In the non-probabilistic setting, the most famous one is the <a href="https://en.wikipedia.org/wiki/Hoare_logic#While_rule" target="_blank" rel="noopener noreferrer">proof rule from Hoare logic (for partial correctness)</a> which says that if we have an <em>invariant</em> for a loop, i.e. a formula that holds before the loop and is maintained during the loop body&#x27;s execution, then we may conclude that the invariant holds after the loop as well.
There is a direct correspondence to this rule in the probabilistic setting.
We call this rule <a href="/docs/proof-rules/induction">Park induction</a>.</p><p>To prove the desired pre being a lower bound on the expected value, we need find a <em>probabilistic invariant</em> <code>I</code>, i.e. an expression that computes an expected value for every program state, such that</p><ol><li>If the loop condition is true, then <code>I</code> must be a lower bound to the expected value of <code>I</code> itself at the end of each single loop iteration,</li><li>If the loop condition is false, then <code>I</code> must be a lower bound to the post (in this case it&#x27;s <code>[true] = 1</code>).</li></ol><p>Note: There is a more formal description on the <a href="/docs/proof-rules/induction">documentation page for the Park induction proof rule</a>.</p><p>This proof rule corresponds to the general proof method of mathematical induction.
The base case is (2) when the loop condition is false and the inductive case is (1) when the loop condition is true, where we only reason about a single loop iteration.</p><p>So what is a valid invariant for our program?
It turns out that <code>exp(0.5, len(l))</code> is a valid invariant:</p><ol><li>If the loop condition is true, then the expected value of <code>exp(0.5, len(l))</code> at the end of the loop iteration is exactly <code>I</code>! Here&#x27;s the calculation:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token plain">  0.5 * exp(0.5, len(pop(l))) + 0.5 * 0</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">= 0.5 * exp(0.5, len(pop(l)))            (simplify)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">= 0.5 * exp(0.5, len(l)-1)               (list_pop axiom)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">= exp(0.5, len(l))                       (exp_step axiom)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li>If the loop condition is false, then <code>I</code> is <code>exp(0.5, 0)</code> which is equivalent to <code>1</code> by the <code>exp_base</code> axiom.</li></ol><p>Caesar has built-in support for Park induction with the <a href="/docs/proof-rules/induction"><code>@invariant</code> annotation for loops</a>.
We add it on top of a loop statement:</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">@invariant</span><span class="token plain">(exp(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> len(l)))</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">while</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">...</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is all we needed to do before we can verify this program.
Before we do so, a warning.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</div><div class="admonitionContent_S0QG"><p>HeyVL is an intermediate verification language and proof rules like Park induction must only be applied where it is sound with respect to the language semantics that we are considering.
In this case, by using Park induction in a <code>proc</code>, we implicitly assumed <em>greatest fixed point</em> semantics on unbounded non-negative expected values for the loop.
It assigns an infinite expected value to nonterminating executions.
Then, Park induction is sound for lower bound reasoning only.</p><p>A more common choice is <em>least fixed point</em> semantics for loops, which assigns zero to nonterminating executions.
There, Park induction is sound only for <em>upper bound reasoning</em> (<a href="#upper-bounds">see below</a>).</p><p>Refer to the <a href="/docs/proof-rules/">proof rules documentation</a> for more information on soundness of proof rules.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="full-example">Running the Complete Example<a href="#full-example" class="hash-link" aria-label="Direct link to Running the Complete Example" title="Direct link to Running the Complete Example">​</a></h3><p>We can now run Caesar on the full example file.
This file is also available in the <a href="https://github.com/moves-rwth/caesar" target="_blank" rel="noopener noreferrer">Github repository</a> at <code>tests/domains/lossy_list.heyvl</code>.</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">domain</span><span class="token plain"> Exponentials </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> exp(base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain">): </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> exp_base </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token plain">. exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain">) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> exp_step </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> base: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UReal</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent: </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain">. exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain">) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> base </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> exp(base</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> exponent)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">domain</span><span class="token plain"> List </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> len(l: List): </span><span class="token builtin" style="color:rgb(72, 118, 214)">UInt</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">func</span><span class="token plain"> pop(l: List): List</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">axiom</span><span class="token plain"> list_pop </span><span class="token operator" style="color:rgb(12, 150, 155)">forall</span><span class="token plain"> l: List. len(pop(l)) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">proc</span><span class="token plain"> lossy_list(init_l: List) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> (l: List)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">pre</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token plain">len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">post</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token boolean" style="color:rgb(188, 84, 84)">true</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> init_l</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">@invariant</span><span class="token plain">(exp(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> len(l)))</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">while</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">var</span><span class="token plain"> prob_choice: </span><span class="token builtin" style="color:rgb(72, 118, 214)">Bool</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> flip(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token plain">)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">if</span><span class="token plain"> prob_choice </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> pop(l)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">assert</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token boolean" style="color:rgb(188, 84, 84)">false</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To verify this example using Caesar, simply run the following command in the Caesar source directory:</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token plain">caesar tests/domains/lossy_list.heyvl</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="upper-bounds">Reasoning About Upper Bounds (Coprocedures)<a href="#upper-bounds" class="hash-link" aria-label="Direct link to Reasoning About Upper Bounds (Coprocedures)" title="Direct link to Reasoning About Upper Bounds (Coprocedures)">​</a></h3><p>In this example, we are reasoning about <em>lower bounds</em> of expected values.
In classical non-probabilistic deductive verification, reasoning about lower bounds of truth values is the default and sufficient for most tasks (the recent interest in <em>incorrectness logics</em> being a trend to the opposite).
In probabilistic, expectation-based reasoning though, it is just as natural to reason about upper bounds of expected values as about lower bounds.
For example, we&#x27;d like to prove an upper bound to the probability of a crash. <small>This is not simply the opposite probability to the probability of a successful run when we also distinguish nontermination from crashes (we do!).</small></p><p>HeyVL supports reasoning about upper bounds as well, via its <code>coproc</code>s.
A <code>coproc</code> is just like a <code>proc</code>, but the <code>pre</code> annotation is interpreted differently.
Instead of noting a <em>lower bound</em> on the expected value of the post, it now denotes an <em>upper bound</em> of the post.
The <code>co</code> prefix indicates that the declaration is dual (in a mathematical sense) to the <code>proc</code> one.
HeyVL also has dual <code>co</code>-versions of its <a href="#verification-statements">verification statements</a>, which will be introduced later.</p><p>Consider the following <code>coproc</code> example (with the domain declarations from above omitted):</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">coproc</span><span class="token plain"> lossy_list_up(init_l: List) </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> (l: List)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">pre</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">post</span><span class="token plain"> len(l)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> init_l</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">@invariant</span><span class="token plain">(exp(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> len(l)))</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">while</span><span class="token plain"> len(l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">var</span><span class="token plain"> prob_choice: </span><span class="token builtin" style="color:rgb(72, 118, 214)">Bool</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> flip(</span><span class="token number" style="color:rgb(170, 9, 130)">0.5</span><span class="token plain">)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">if</span><span class="token plain"> prob_choice </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            l </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> pop(l)</span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">assert</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token boolean" style="color:rgb(188, 84, 84)">false</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this example, we prove an upper bound of zero to the expected value of <code>len(l)</code> on termination.
For simplicity, we&#x27;ll use <a href="/docs/proof-rules/induction">Park induction</a> again.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_S0QG"><p>We are now using Park induction with upper bounds, which means the proof rule only gives us an upper bound to the <em>least fixed point</em> of the loop semantics.
Before, we reasoned about greatest fixed point semantics!</p><p>As we&#x27;ve said above, the least fixed point semantics assigns expected value <strong>zero</strong> to nonterminating runs (as opposed to <strong>infinity</strong> for greatest fixed point semantics).
Thus, now we are only proving an upper bound on the expected value of <code>len(l)</code> <em>only for the terminating executions AND those which do not crash</em>.
If we hit the <code>assert [false]</code> statement, then the expected value will be zero and those executions will verify trivially since HeyVL&#x27;s expected values are always nonnegative.</p><p>Caesar has other proof rules built-in that allow reasoning about lower bounds of least fixed points and upper bounds of greatest fixed points.
See the <a href="/docs/proof-rules/">proof rules documentation</a>.</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="verification-statements">Verification Statements<a href="#verification-statements" class="hash-link" aria-label="Direct link to Verification Statements" title="Direct link to Verification Statements">​</a></h2><p>In addition to HeyVL&#x27;s &quot;normal&quot; programming constructs such as assignments <code>x = e</code>, <code>if (b) { ... } else { ... }</code>, Caesar has statements that are specific to program verification.
There are <code>assert</code> statements which add proof obligations, <code>assume</code> statements which allow to add assumptions, and nondeterministic choices.</p><p>In the following, we&#x27;ll explain HeyVL&#x27;s verification statements by explaining how the <a href="#full-example">lossy list example</a> is internally rewritten to loop-free HeyVL code with verification statements.
For reference-level documentation, refer to the <a href="/docs/heyvl/statements">HeyVL statements documentation</a>.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>Our <a href="/docs/publications#oospla-23">OOPLSA &#x27;23 publication <em>&quot;A Deductive Verification Infrastructure for Probabilistic Programs&quot;</em></a> (<a href="https://arxiv.org/pdf/2309.07781.pdf" target="_blank" rel="noopener noreferrer">direct link to extended version pdf</a>) is a formal treatment of HeyVL&#x27;s verification statements.
It is a highly recommended read to understand HeyVL&#x27;s verification statements in detail and from the bottom up.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="boolean-verification-statements">Boolean Verification Statements<a href="#boolean-verification-statements" class="hash-link" aria-label="Direct link to Boolean Verification Statements" title="Direct link to Boolean Verification Statements">​</a></h3><p>HeyVL&#x27;s verification statements are quantitative generalizations of classical verification statements that can be found in deductive verifiers such as <a href="https://dafny.org/" target="_blank" rel="noopener noreferrer">Dafny</a>.
This means that when we only reason about Boolean properties, i.e. whether a property holds in certain states or not (as opposed to expected values of such predicates), then HeyVL&#x27;s verification statements behave <em>exactly</em> as their qualitative (Boolean) counterparts.
This is why we&#x27;ll start our explanation with non-probabilistic intuition before we delve into more detail about <a href="#expectation-based-reasoning"><em>expectation-based reasoning</em></a>, the generalization to the quantitative setting.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="embed-expressions">Embed Expressions<a href="#embed-expressions" class="hash-link" aria-label="Direct link to Embed Expressions" title="Direct link to Embed Expressions">​</a></h4><p>An embed <a href="/docs/heyvl/expressions">expression</a> <code>?(b)</code> takes a Boolean expression <code>b</code> and maps it to <code>∞</code> if <code>b</code> evaluates to <code>true</code> and to <code>0</code> otherwise.
It can be expressed by Iverson brackets <code>[b]</code> via <code>[b] * ∞</code>.</p><p>Thus, embed expressions <em>embed</em> Boolean expressions into the quantitative verification domain that Caesar uses where values are not just <code>false</code> and <code>true</code>, but everything from the real number <code>0</code> up to and including <code>∞</code>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="boolean-assertions">Boolean Assertions<a href="#boolean-assertions" class="hash-link" aria-label="Direct link to Boolean Assertions" title="Direct link to Boolean Assertions">​</a></h4><p>A Boolean assertion is used to say that a predicate is true at this location.
For example,</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">assert</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">?</span><span class="token plain">(len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>will require that <code>len(init_l)</code> is at least one.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="boolean-assumptions">Boolean Assumptions<a href="#boolean-assumptions" class="hash-link" aria-label="Direct link to Boolean Assumptions" title="Direct link to Boolean Assumptions">​</a></h4><p>A Boolean assumption is used to instruct the verifier that a Boolean expression can be assumed to be true at this point without proof.
For example,</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">assume</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">?</span><span class="token plain">(len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>will assume that <code>len(init_l)</code> is one.
Executions that do not satisfy the Boolean expression are ignored by the verifier.</p><p>For example, consider this piece of code:</p><div class="language-heyvl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-heyvl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">assume</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">?</span><span class="token plain">(len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token plain">); </span><span class="token keyword" style="color:rgb(12, 150, 155)">assert</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">?</span><span class="token plain">(len(init_l) </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The assertion will never fail since we assume in all executions that the assertion <code>len(init_l) == 1</code> is true and thus also <code>len(init_l) &gt; 0</code> holds.</p><p>Note that <code>assume ?(false)</code> will assume <code>false</code>, i.e. everything following after this statement will verify.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="expectation-based-reasoning">Expectation-Based Reasoning<a href="#expectation-based-reasoning" class="hash-link" aria-label="Direct link to Expectation-Based Reasoning" title="Direct link to Expectation-Based Reasoning">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-and-assertions">Assumptions and Assertions<a href="#assumptions-and-assertions" class="hash-link" aria-label="Direct link to Assumptions and Assertions" title="Direct link to Assumptions and Assertions">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="havoc">Havoc<a href="#havoc" class="hash-link" aria-label="Direct link to Havoc" title="Direct link to Havoc">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nondeterministic-choice">Nondeterministic Choice<a href="#nondeterministic-choice" class="hash-link" aria-label="Direct link to Nondeterministic Choice" title="Direct link to Nondeterministic Choice">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rewards">Rewards<a href="#rewards" class="hash-link" aria-label="Direct link to Rewards" title="Direct link to Rewards">​</a></h3></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/moves-rwth/caesar/tree/main/website/docs/getting-started/heyvl-guide.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/getting-started/installation"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Installing Caesar</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/getting-started/zoo-of-heyvl-examples"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">A Zoo of HeyVL Examples</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-are-heyvl-and-caesar" class="table-of-contents__link toc-highlight">What are HeyVL and Caesar?</a><ul><li><a href="#architecture" class="table-of-contents__link toc-highlight">Architecture</a></li><li><a href="#features" class="table-of-contents__link toc-highlight">Features</a></li></ul></li><li><a href="#verifying-our-first-program-lossy-list-traversal" class="table-of-contents__link toc-highlight">Verifying Our First Program: Lossy List Traversal</a><ul><li><a href="#the-probabilistic-program-itself" class="table-of-contents__link toc-highlight">The Probabilistic Program Itself</a></li><li><a href="#user-defined-datatypes-and-functions" class="table-of-contents__link toc-highlight">User-Defined Datatypes and Functions</a></li><li><a href="#specifications-and-invariants" class="table-of-contents__link toc-highlight">Specifications and Invariants</a></li><li><a href="#full-example" class="table-of-contents__link toc-highlight">Running the Complete Example</a></li><li><a href="#upper-bounds" class="table-of-contents__link toc-highlight">Reasoning About Upper Bounds (Coprocedures)</a></li></ul></li><li><a href="#verification-statements" class="table-of-contents__link toc-highlight">Verification Statements</a><ul><li><a href="#boolean-verification-statements" class="table-of-contents__link toc-highlight">Boolean Verification Statements</a></li><li><a href="#expectation-based-reasoning" class="table-of-contents__link toc-highlight">Expectation-Based Reasoning</a></li><li><a href="#assumptions-and-assertions" class="table-of-contents__link toc-highlight">Assumptions and Assertions</a></li><li><a href="#havoc" class="table-of-contents__link toc-highlight">Havoc</a></li><li><a href="#nondeterministic-choice" class="table-of-contents__link toc-highlight">Nondeterministic Choice</a></li><li><a href="#rewards" class="table-of-contents__link toc-highlight">Rewards</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/getting-started">Getting Started</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/heyvl">HeyVL</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/stdlib">Standard Library</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/pgcl">pGCL</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/moves-rwth/caesar/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">Caesar Discussions<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a class="footer__link-item" href="/docs/publications">Academic Publications</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">News</a></li><li class="footer__item"><a href="https://github.com/moves-rwth/caesar" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Caesar Developers. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.639b0ec0.js"></script>
<script src="/assets/js/main.74b8c474.js"></script>
</body>
</html>