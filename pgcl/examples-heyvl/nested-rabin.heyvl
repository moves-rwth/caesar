// Auto-generated by pgcl2heyvl from nested-rabin.pgcl
//
// HeyVL file to show
//     [(n <= 5) && (i <= 5)] * ([1 == i] + ([1 < i] * (2/3))) <= wlp[C]([(n <= 5) && (i <= 5)] * [i == 1])
// using k-induction with k = 1 and invariant = [(n <= 5) && (i <= 5)] * ([1 == i] + ([1 < i] * (2/3))), k = 1 and invariant = ([(n <= 5) && (i <= 5)] * [(0 <= n) && (n <= i)]) * (((2/3) * (1 - ((([i == n] * (n + 1)) * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32)))) + ([i == (n + 1)] * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32))))))) + ((([i == n] * n) * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32)))) + ([i == (n + 1)] * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32))))))
// for the pGCL program C:
//
//     nat i;
//     nat n;
//     nat d;
//     const bounds := (n <= 5) & (i <= 5);
//     const invar1 := 1 - ((([i = n] * (n + 1)) * (((((([n = 0] * 1) + ([n = 1] * 1/2)) + ([n = 2] * 1/4)) + ([n = 3] * 1/8)) + ([n = 4] * 1/16)) + ([n = 5] * 1/32))) + ([i = (n + 1)] * (((((([n = 0] * 1) + ([n = 1] * 1/2)) + ([n = 2] * 1/4)) + ([n = 3] * 1/8)) + ([n = 4] * 1/16)) + ([n = 5] * 1/32))));
//     const invar2 := (([i = n] * n) * (((((([n = 0] * 1) + ([n = 1] * 1/2)) + ([n = 2] * 1/4)) + ([n = 3] * 1/8)) + ([n = 4] * 1/16)) + ([n = 5] * 1/32))) + ([i = (n + 1)] * (((((([n = 0] * 1) + ([n = 1] * 1/2)) + ([n = 2] * 1/4)) + ([n = 3] * 1/8)) + ([n = 4] * 1/16)) + ([n = 5] * 1/32)));
//     const rec_pown_2 := ((((([n = 0] * 1) + ([n = 1] * 1/2)) + ([n = 2] * 1/4)) + ([n = 3] * 1/8)) + ([n = 4] * 1/16)) + ([n = 5] * 1/32);
//     while (1 < i) {
//         n := i;
//         while (0 < n) {
//             {
//                 d := 0;
//             } [0.5] {
//                 d := 1;
//             }
//             i := i - d;
//             n := n - 1;
//         }
//     }

@wlp
proc main(init_i: UInt, init_n: UInt, init_d: UInt) -> (i: UInt, n: UInt, d: UInt)
    pre [(init_n <= 5) && (init_i <= 5)] * ([1 == init_i] + ([1 < init_i] * (2/3)))
    post [(n <= 5) && (i <= 5)] * [i == 1]
{
    var prob_choice: Bool
    i = init_i
    n = init_n
    d = init_d
    @invariant([(n <= 5) && (i <= 5)] * ([1 == i] + ([1 < i] * (2/3))))
    while 1 < i {
        n = i
        @invariant(([(n <= 5) && (i <= 5)] * [(0 <= n) && (n <= i)]) * (((2/3) * (1 - ((([i == n] * (n + 1)) * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32)))) + ([i == (n + 1)] * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32))))))) + ((([i == n] * n) * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32)))) + ([i == (n + 1)] * (((((([n == 0] * 1) + ([n == 1] * (1/2))) + ([n == 2] * (1/4))) + ([n == 3] * (1/8))) + ([n == 4] * (1/16))) + ([n == 5] * (1/32)))))))
        while 0 < n {
            prob_choice = flip(0.5)
            if prob_choice {
                d = 0
            } else {
                d = 1
            }
            i = i - d
            n = n - 1
        }
    }
}
